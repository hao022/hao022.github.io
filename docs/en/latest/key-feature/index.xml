<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Key Feature on HUATUO Doc</title>
    <link>https://huatuo.tech/docs/en/latest/key-feature/</link>
    <description>Recent content in Key Feature on HUATUO Doc</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 11 Jan 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://huatuo.tech/docs/en/latest/key-feature/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Metrics</title>
      <link>https://huatuo.tech/docs/en/latest/key-feature/metrics/</link>
      <pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://huatuo.tech/docs/en/latest/key-feature/metrics/</guid>
      <description>&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Subsystem&lt;/th&gt;&#xA;          &lt;th&gt;Metric&lt;/th&gt;&#xA;          &lt;th&gt;Description&lt;/th&gt;&#xA;          &lt;th&gt;Unit&lt;/th&gt;&#xA;          &lt;th&gt;Dimension&lt;/th&gt;&#xA;          &lt;th&gt;Source&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_util_sys&lt;/td&gt;&#xA;          &lt;td&gt;Time of running kernel processes percentage of host&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on cpuacct.stat and cpuacct.usage&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_util_usr&lt;/td&gt;&#xA;          &lt;td&gt;Time of running user processes percentage of host&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on cpuacct.stat and cpuacct.usage&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_util_total&lt;/td&gt;&#xA;          &lt;td&gt;Total time of running percentage of host&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on cpuacct.stat and cpuacct.usage&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_util_container_sys&lt;/td&gt;&#xA;          &lt;td&gt;Time of running kernel processes percentage of container&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on cpuacct.stat and cpuacct.usage&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_util_container_usr&lt;/td&gt;&#xA;          &lt;td&gt;Time of running user processes percentage of container&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on cpuacct.stat and cpuacct.usage&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_util_container_total&lt;/td&gt;&#xA;          &lt;td&gt;Total time of running percentage of container&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on cpuacct.stat and cpuacct.usage&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_stat_container_burst_time&lt;/td&gt;&#xA;          &lt;td&gt;Cumulative wall-time (in nanoseconds) that any CPUs has used above quota in respective periods&lt;/td&gt;&#xA;          &lt;td&gt;ns&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;cpu.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_stat_container_nr_bursts&lt;/td&gt;&#xA;          &lt;td&gt;Number of periods burst occurs&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;cpu.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_stat_container_nr_throttled&lt;/td&gt;&#xA;          &lt;td&gt;Number of times the group has been throttled/limited&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;cpu.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_stat_container_exter_wait_rate&lt;/td&gt;&#xA;          &lt;td&gt;Wait rate caused by processes outside the container&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_stat_container_inner_wait_rate&lt;/td&gt;&#xA;          &lt;td&gt;Wait rate caused by processes inside the container&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_stat_container_throttle_wait_rate&lt;/td&gt;&#xA;          &lt;td&gt;Wait rate caused by throttle of container&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;cpu_stat_container_wait_rate&lt;/td&gt;&#xA;          &lt;td&gt;Total wait rate: exter_wait_rate + inner_wait_rate + throttle_wait_rate&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;loadavg_container_container_nr_running&lt;/td&gt;&#xA;          &lt;td&gt;The number of running tasks in the container&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;get from kernel via netlink&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;loadavg_container_container_nr_uninterruptible&lt;/td&gt;&#xA;          &lt;td&gt;The number of uninterruptible tasks in the container&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;get from kernel via netlink&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;loadavg_load1&lt;/td&gt;&#xA;          &lt;td&gt;System load avg over the last 1 minute&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;loadavg_load5&lt;/td&gt;&#xA;          &lt;td&gt;System load avg over the last 5 minute&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;loadavg_load15&lt;/td&gt;&#xA;          &lt;td&gt;system load avg over the last 15 minute&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;monsoftirq_latency&lt;/td&gt;&#xA;          &lt;td&gt;The number of NET_RX/NET_TX irq latency happend in the following regions:&lt;br&gt;0~10 us&lt;br&gt;100us ~ 1ms&lt;br&gt;10us ~ 100us&lt;br&gt;1ms ~ inf&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;hook the softirq event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;runqlat_container_nlat_01&lt;/td&gt;&#xA;          &lt;td&gt;The number of times when schedule latency of processes in the container is within 0~10ms&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;hook the scheduling switch event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;runqlat_container_nlat_02&lt;/td&gt;&#xA;          &lt;td&gt;The number of times when schedule latency of processes in the container is within 10~20ms&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;hook the scheduling switch event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;runqlat_container_nlat_03&lt;/td&gt;&#xA;          &lt;td&gt;The number of times when schedule latency of processes in the container is within 20~50ms&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;hook the scheduling switch event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;runqlat_container_nlat_04&lt;/td&gt;&#xA;          &lt;td&gt;The number of times when schedule latency of processes in the container is more than 50ms&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;hook the scheduling switch event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;runqlat_g_nlat_01&lt;/td&gt;&#xA;          &lt;td&gt;The number of times when schedule latency of processes in the host is within&lt;br&gt;0~10ms&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;hook the scheduling switch event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;runqlat_g_nlat_02&lt;/td&gt;&#xA;          &lt;td&gt;The number of times when schedule latency of processes in the host is within 10~20ms&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;hook the scheduling switch event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;runqlat_g_nlat_03&lt;/td&gt;&#xA;          &lt;td&gt;The number of times when schedule latency of processes in the host is within 20~50ms&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;hook the scheduling switch event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;runqlat_g_nlat_04&lt;/td&gt;&#xA;          &lt;td&gt;The number of times when schedule latency of processes in the host is more than 50ms&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;hook the scheduling switch event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpu&lt;/td&gt;&#xA;          &lt;td&gt;reschedipi_oversell_probability&lt;/td&gt;&#xA;          &lt;td&gt;The possibility of cpu overselling exists on the host where the vm is located&lt;/td&gt;&#xA;          &lt;td&gt;0-1&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;hook the scheduling ipi event and do time statistics via bpf&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;buddyinfo_blocks&lt;/td&gt;&#xA;          &lt;td&gt;Kernel memory allocator information&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_events_container_watermark_inc&lt;/td&gt;&#xA;          &lt;td&gt;Counts of memory allocation watermark increasing&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.events&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_events_container_watermark_dec&lt;/td&gt;&#xA;          &lt;td&gt;Counts of memory allocation watermark decreasing&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.events&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_others_container_local_direct_reclaim_time&lt;/td&gt;&#xA;          &lt;td&gt;Time speed in page allocation in memory cgroup&lt;/td&gt;&#xA;          &lt;td&gt;nanosecond&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.local_direct_reclaim_time&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_others_container_directstall_time&lt;/td&gt;&#xA;          &lt;td&gt;Memory cgroup&amp;rsquo;s direct reclaim time in try_charge&lt;/td&gt;&#xA;          &lt;td&gt;nanosecond&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.directstall_stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_others_container_asyncreclaim_time&lt;/td&gt;&#xA;          &lt;td&gt;Memory cgroup&amp;rsquo;s direct reclaim time in cgroup async memory reclaim&lt;/td&gt;&#xA;          &lt;td&gt;nanosecond&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.asynreclaim_stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;priority_reclaim_kswapd&lt;/td&gt;&#xA;          &lt;td&gt;Kswapd&amp;rsquo;s reclaim stat in priority reclaiming&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;priority_reclaim_direct&lt;/td&gt;&#xA;          &lt;td&gt;Direct reclaim stat in priority reclaiming&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_writeback&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of file/anon cache that are queued for syncing to disk&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_unevictable&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of memory that cannot be reclaimed (mlocked etc)&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_shmem&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of shmem memory&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgsteal_kswapd&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of reclaimed memory by kswapd and cswapd&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgsteal_globalkswapd&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of reclaimed memory by kswapd&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgsteal_globaldirect&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of reclaimed memory by direct reclaim during page allocation&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgsteal_direct&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of reclaimed memory by direct reclaim during page allocation and try_charge&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgsteal_cswapd&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of reclaimed memory by cswapd&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgscan_kswapd&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of scanned memory by kswapd and cswapd&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgscan_globalkswapd&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of scanned memory by kswapd&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgscan_globaldirect&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of scanned memory by direct reclaim during page allocation&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgscan_direct&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of scanned memory by direct reclaim during page allocation and try_charge&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgscan_cswapd&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of scanned memory by cswapd&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgrefill&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of memory that is scanned in active list&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_pgdeactivate&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of memory that is deactivated into inactive list&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_inactive_file&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of file-backed memory on inactive lru list.&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_inactive_anon&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of anonymous and swap cache memory on inactive lru list&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_dirty&lt;/td&gt;&#xA;          &lt;td&gt;Bytes that are waiting to get written back to the disk&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_active_file&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of file-backed memory on active lru list&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;memory_stat_container_active_anon&lt;/td&gt;&#xA;          &lt;td&gt;Bytes of anonymous and swap cache memory on active lru list&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;memory.stat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;mountpoint_perm_ro&lt;/td&gt;&#xA;          &lt;td&gt;Whether mountpoint is readonly or not&lt;/td&gt;&#xA;          &lt;td&gt;bool&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_allocstall_normal&lt;/td&gt;&#xA;          &lt;td&gt;Host direct reclaim count on normal zone&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_allocstall_movable&lt;/td&gt;&#xA;          &lt;td&gt;Host direct reclaim count on movable zone&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_compact_stall&lt;/td&gt;&#xA;          &lt;td&gt;Count of memory compaction&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_active_anon&lt;/td&gt;&#xA;          &lt;td&gt;Number of anonymous pages on active lru&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_active_file&lt;/td&gt;&#xA;          &lt;td&gt;Number of file-backed pages on active lru&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_boost_pages&lt;/td&gt;&#xA;          &lt;td&gt;Number of pages in kswapd boosting&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_dirty&lt;/td&gt;&#xA;          &lt;td&gt;Number of dirty pages&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_free_pages&lt;/td&gt;&#xA;          &lt;td&gt;Number of free pages&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_inactive_anon&lt;/td&gt;&#xA;          &lt;td&gt;Number of anonymous pages on inactive lru&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_inactive_file&lt;/td&gt;&#xA;          &lt;td&gt;Number of file-backed pages on inactive lru&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_kswapd_boost&lt;/td&gt;&#xA;          &lt;td&gt;Count of kswapd boosting&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_mlock&lt;/td&gt;&#xA;          &lt;td&gt;Number of locked pages&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_shmem&lt;/td&gt;&#xA;          &lt;td&gt;Number of shmem pages&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_slab_reclaimable&lt;/td&gt;&#xA;          &lt;td&gt;Number of relcaimable slab pages&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_slab_unreclaimable&lt;/td&gt;&#xA;          &lt;td&gt;Number of unrelcaimable slab pages&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_unevictable&lt;/td&gt;&#xA;          &lt;td&gt;Number of unevictable pages&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_nr_writeback&lt;/td&gt;&#xA;          &lt;td&gt;Number of writebacking pages&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_numa_pages_migrated&lt;/td&gt;&#xA;          &lt;td&gt;Number of pages in numa migrating&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_pgdeactivate&lt;/td&gt;&#xA;          &lt;td&gt;Number of pages which are deactivated into inactive lru&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_pgrefill&lt;/td&gt;&#xA;          &lt;td&gt;Number of pages which are scanned on active lru&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_pgscan_direct&lt;/td&gt;&#xA;          &lt;td&gt;Number of pages which are scanned in direct reclaim&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_pgscan_kswapd&lt;/td&gt;&#xA;          &lt;td&gt;Number of pages which are scanned in kswapd reclaim&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_pgsteal_direct&lt;/td&gt;&#xA;          &lt;td&gt;Number of pages which are reclaimed in direct reclaim&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;vmstat_pgsteal_kswapd&lt;/td&gt;&#xA;          &lt;td&gt;Number of pages which are reclaimed in kswapd reclaim&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;/proc/vmstat&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;hungtask_happened&lt;/td&gt;&#xA;          &lt;td&gt;Count of hungtask events&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;oom_happened&lt;/td&gt;&#xA;          &lt;td&gt;Count of oom events&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;softlockup_happened&lt;/td&gt;&#xA;          &lt;td&gt;Count of softlockup events&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;mmhostbpf_compactionstat&lt;/td&gt;&#xA;          &lt;td&gt;Time speed in memory compaction&lt;/td&gt;&#xA;          &lt;td&gt;nanosecond&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;mmhostbpf_allocstallstat&lt;/td&gt;&#xA;          &lt;td&gt;Time speed in memory direct reclaim on host&lt;/td&gt;&#xA;          &lt;td&gt;nanosecond&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memory&lt;/td&gt;&#xA;          &lt;td&gt;mmcgroupbpf_container_directstallcount&lt;/td&gt;&#xA;          &lt;td&gt;Count of cgroup&amp;rsquo;s try_charge direct reclaim&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;IO&lt;/td&gt;&#xA;          &lt;td&gt;iolatency_disk_d2c&lt;/td&gt;&#xA;          &lt;td&gt;Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;IO&lt;/td&gt;&#xA;          &lt;td&gt;iolatency_disk_q2c&lt;/td&gt;&#xA;          &lt;td&gt;Statistics of io latency for the entire io lifecycle when accessing the disk&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;IO&lt;/td&gt;&#xA;          &lt;td&gt;iolatency_container_d2c&lt;/td&gt;&#xA;          &lt;td&gt;Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;IO&lt;/td&gt;&#xA;          &lt;td&gt;iolatency_container_q2c&lt;/td&gt;&#xA;          &lt;td&gt;Statistics of io latency for the entire io lifecycle when accessing the disk&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;IO&lt;/td&gt;&#xA;          &lt;td&gt;iolatency_disk_flush&lt;/td&gt;&#xA;          &lt;td&gt;Statistics of delay for flush operations on disk raid device&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;IO&lt;/td&gt;&#xA;          &lt;td&gt;iolatency_container_flush&lt;/td&gt;&#xA;          &lt;td&gt;Statistics of delay for flush operations on disk raid devices caused by containers&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;container&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;IO&lt;/td&gt;&#xA;          &lt;td&gt;iolatency_disk_freeze&lt;/td&gt;&#xA;          &lt;td&gt;Statistics of disk freeze events&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;performance and statistics monitoring for BPF Programs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;tcp_mem_limit_pages&lt;/td&gt;&#xA;          &lt;td&gt;System TCP total memory size limit&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;tcp_mem_usage_bytes&lt;/td&gt;&#xA;          &lt;td&gt;The total number of bytes of TCP memory used by the system&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;tcp_mem_usage_pages * page_size&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;tcp_mem_usage_pages&lt;/td&gt;&#xA;          &lt;td&gt;The total size of TCP memory used by the system&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;tcp_mem_usage_percent&lt;/td&gt;&#xA;          &lt;td&gt;The percentage of TCP memory used by the system to the limit size&lt;/td&gt;&#xA;          &lt;td&gt;%&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;tcp_mem_usage_pages / tcp_mem_limit_pages&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;arp_entries&lt;/td&gt;&#xA;          &lt;td&gt;The number of arp cache entries&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;arp_total&lt;/td&gt;&#xA;          &lt;td&gt;Total number of arp cache entries&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;qdisc_backlog&lt;/td&gt;&#xA;          &lt;td&gt;The number of bytes queued to be sent&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;sum of same level(parent major) for a device&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;qdisc_bytes_total&lt;/td&gt;&#xA;          &lt;td&gt;The number of bytes sent&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;sum of same level(parent major) for a device&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;qdisc_current_queue_length&lt;/td&gt;&#xA;          &lt;td&gt;The number of packets queued for sending&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;sum of same level(parent major) for a device&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;qdisc_drops_total&lt;/td&gt;&#xA;          &lt;td&gt;The number of discarded packets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;sum of same level(parent major) for a device&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;qdisc_overlimits_total&lt;/td&gt;&#xA;          &lt;td&gt;The number of queued packets exceeds the limit&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;sum of same level(parent major) for a device&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;qdisc_packets_total&lt;/td&gt;&#xA;          &lt;td&gt;The number of packets sent&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;sum of same level(parent major) for a device&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;qdisc_requeues_total&lt;/td&gt;&#xA;          &lt;td&gt;The number of packets that were not sent successfully and were requeued&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;sum of same level(parent major) for a device&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;ethtool_hardware_rx_dropped_errors&lt;/td&gt;&#xA;          &lt;td&gt;Statistics of inbound packet droped or errors of interface&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host&lt;/td&gt;&#xA;          &lt;td&gt;related to hardware drivers, such as mlx, ixgbe, bnxt_en, etc.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_receive_bytes_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of good received bytes&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_receive_compressed_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of correctly received compressed packets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_receive_dropped_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of packets received but not processed&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_receive_errors_total&lt;/td&gt;&#xA;          &lt;td&gt;Total number of bad packets received on this network device&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_receive_fifo_total&lt;/td&gt;&#xA;          &lt;td&gt;Receiver FIFO error counter&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_receive_frame_total&lt;/td&gt;&#xA;          &lt;td&gt;Receiver frame alignment errors&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_receive_multicast_total&lt;/td&gt;&#xA;          &lt;td&gt;Multicast packets received. For hardware interfaces this statistic is commonly calculated at the device level (unlike rx_packets) and therefore may include packets which did not reach the host&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_receive_packets_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of good packets received by the interface&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_transmit_bytes_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of good transmitted bytes, corresponding to tx_packets&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_transmit_carrier_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of frame transmission errors due to loss of carrier during transmission&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_transmit_colls_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of collisions during packet transmissions&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_transmit_compressed_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of transmitted compressed packets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_transmit_dropped_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of packets dropped on their way to transmission, e.g. due to lack of resources&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_transmit_errors_total&lt;/td&gt;&#xA;          &lt;td&gt;Total number of transmit problems&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_transmit_fifo_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of frame transmission errors due to device FIFO underrun / underflow&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netdev_transmit_packets_total&lt;/td&gt;&#xA;          &lt;td&gt;Number of packets successfully transmitted&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_ArpFilter&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_BusyPollRxPackets&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_DelayedACKLocked&lt;/td&gt;&#xA;          &lt;td&gt;A delayed ACK timer expires, but the TCP stack can’t send an ACK immediately due to the socket is locked by a userspace program. The TCP stack will send a pure ACK later (after the userspace program unlock the socket). When the TCP stack sends the pure ACK later, the TCP stack will also update TcpExtDelayedACKs and exit the delayed ACK mode&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_DelayedACKLost&lt;/td&gt;&#xA;          &lt;td&gt;It will be updated when the TCP stack receives a packet which has been ACKed. A Delayed ACK loss might cause this issue, but it would also be triggered by other reasons, such as a packet is duplicated in the network&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_DelayedACKs&lt;/td&gt;&#xA;          &lt;td&gt;A delayed ACK timer expires. The TCP stack will send a pure ACK packet and exit the delayed ACK mode&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_EmbryonicRsts&lt;/td&gt;&#xA;          &lt;td&gt;resets received for embryonic SYN_RECV sockets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_IPReversePathFilter&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_ListenDrops&lt;/td&gt;&#xA;          &lt;td&gt;When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_ListenOverflows&lt;/td&gt;&#xA;          &lt;td&gt;When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_LockDroppedIcmps&lt;/td&gt;&#xA;          &lt;td&gt;ICMP packets dropped because socket was locked&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_OfoPruned&lt;/td&gt;&#xA;          &lt;td&gt;The TCP stack tries to discard packet on the out of order queue&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_OutOfWindowIcmps&lt;/td&gt;&#xA;          &lt;td&gt;ICMP pkts dropped because they were out-of-window&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_PAWSActive&lt;/td&gt;&#xA;          &lt;td&gt;Packets are dropped by PAWS in Syn-Sent status&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_PAWSEstab&lt;/td&gt;&#xA;          &lt;td&gt;Packets are dropped by PAWS in any status other than Syn-Sent&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_PFMemallocDrop&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_PruneCalled&lt;/td&gt;&#xA;          &lt;td&gt;The TCP stack tries to reclaim memory for a socket. After updates this counter, the TCP stack will try to collapse the out of order queue and the receiving queue. If the memory is still not enough, the TCP stack will try to discard packets from the out of order queue (and update the TcpExtOfoPruned counter)&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_RcvPruned&lt;/td&gt;&#xA;          &lt;td&gt;After ‘collapse’ and discard packets from the out of order queue, if the actually used memory is still larger than the max allowed memory, this counter will be updated. It means the ‘prune’ fails&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_SyncookiesFailed&lt;/td&gt;&#xA;          &lt;td&gt;The MSS decoded from the SYN cookie is invalid. When this counter is updated, the received packet won’t be treated as a SYN cookie and the TcpExtSyncookiesRecv counter won’t be updated&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_SyncookiesRecv&lt;/td&gt;&#xA;          &lt;td&gt;How many reply packets of the SYN cookies the TCP stack receives&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_SyncookiesSent&lt;/td&gt;&#xA;          &lt;td&gt;It indicates how many SYN cookies are sent&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPACKSkippedChallenge&lt;/td&gt;&#xA;          &lt;td&gt;The ACK is skipped if the ACK is a challenge ACK&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPACKSkippedFinWait2&lt;/td&gt;&#xA;          &lt;td&gt;The ACK is skipped in Fin-Wait-2 status, the reason would be either PAWS check fails or the received sequence number is out of window&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPACKSkippedPAWS&lt;/td&gt;&#xA;          &lt;td&gt;The ACK is skipped due to PAWS (Protect Against Wrapped Sequence numbers) check fails&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPACKSkippedSeq&lt;/td&gt;&#xA;          &lt;td&gt;The sequence number is out of window and the timestamp passes the PAWS check and the TCP status is not Syn-Recv, Fin-Wait-2, and Time-Wait&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPACKSkippedSynRecv&lt;/td&gt;&#xA;          &lt;td&gt;The ACK is skipped in Syn-Recv status. The Syn-Recv status means the TCP stack receives a SYN and replies SYN+ACK&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPACKSkippedTimeWait&lt;/td&gt;&#xA;          &lt;td&gt;The ACK is skipped in Time-Wait status, the reason would be either PAWS check failed or the received sequence number is out of window&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPAbortFailed&lt;/td&gt;&#xA;          &lt;td&gt;The kernel TCP layer will send RST if the RFC2525 2.17 section is satisfied. If an internal error occurs during this process, TcpExtTCPAbortFailed will be increased&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPAbortOnClose&lt;/td&gt;&#xA;          &lt;td&gt;Number of sockets closed when the user-mode program has data in the buffer&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPAbortOnData&lt;/td&gt;&#xA;          &lt;td&gt;It means TCP layer has data in flight, but need to close the connection&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPAbortOnLinger&lt;/td&gt;&#xA;          &lt;td&gt;When a TCP connection comes into FIN_WAIT_2 state, instead of waiting for the fin packet from the other side, kernel could send a RST and delete the socket immediately&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPAbortOnMemory&lt;/td&gt;&#xA;          &lt;td&gt;When an application closes a TCP connection, kernel still need to track the connection, let it complete the TCP disconnect process&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPAbortOnTimeout&lt;/td&gt;&#xA;          &lt;td&gt;This counter will increase when any of the TCP timers expire. In such situation, kernel won’t send RST, just give up the connection&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPAckCompressed&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPAutoCorking&lt;/td&gt;&#xA;          &lt;td&gt;When sending packets, the TCP layer will try to merge small packets to a bigger one&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPBacklogDrop&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPChallengeACK&lt;/td&gt;&#xA;          &lt;td&gt;The number of challenge acks sent&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDSACKIgnoredNoUndo&lt;/td&gt;&#xA;          &lt;td&gt;When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDSACKIgnoredOld&lt;/td&gt;&#xA;          &lt;td&gt;When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDSACKOfoRecv&lt;/td&gt;&#xA;          &lt;td&gt;The TCP stack receives a DSACK, which indicate an out of order duplicate packet is received&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDSACKOfoSent&lt;/td&gt;&#xA;          &lt;td&gt;The TCP stack receives an out of order duplicate packet, so it sends a DSACK to the sender&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDSACKOldSent&lt;/td&gt;&#xA;          &lt;td&gt;The TCP stack receives a duplicate packet which has been acked, so it sends a DSACK to the sender&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDSACKRecv&lt;/td&gt;&#xA;          &lt;td&gt;The TCP stack receives a DSACK, which indicates an acknowledged duplicate packet is received&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDSACKUndo&lt;/td&gt;&#xA;          &lt;td&gt;Congestion window recovered without slow start using DSACK&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDeferAcceptDrop&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDelivered&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPDeliveredCE&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFastOpenActive&lt;/td&gt;&#xA;          &lt;td&gt;When the TCP stack receives an ACK packet in the SYN-SENT status, and the ACK packet acknowledges the data in the SYN packet, the TCP stack understand the TFO cookie is accepted by the other side, then it updates this counter&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFastOpenActiveFail&lt;/td&gt;&#xA;          &lt;td&gt;Fast Open attempts (SYN/data) failed because the remote does not accept it or the attempts timed out&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFastOpenBlackhole&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFastOpenCookieReqd&lt;/td&gt;&#xA;          &lt;td&gt;This counter indicates how many times a client wants to request a TFO cookie&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFastOpenListenOverflow&lt;/td&gt;&#xA;          &lt;td&gt;When the pending fast open request number is larger than fastopenq-&amp;gt;max_qlen, the TCP stack will reject the fast open request and update this counter&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFastOpenPassive&lt;/td&gt;&#xA;          &lt;td&gt;This counter indicates how many times the TCP stack accepts the fast open request&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFastOpenPassiveFail&lt;/td&gt;&#xA;          &lt;td&gt;This counter indicates how many times the TCP stack rejects the fast open request. It is caused by either the TFO cookie is invalid or the TCP stack finds an error during the socket creating process&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFastRetrans&lt;/td&gt;&#xA;          &lt;td&gt;The TCP stack wants to retransmit a packet and the congestion control state is not ‘Loss’&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFromZeroWindowAdv&lt;/td&gt;&#xA;          &lt;td&gt;The TCP receive window is set to no-zero value from zero&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPFullUndo&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPHPAcks&lt;/td&gt;&#xA;          &lt;td&gt;If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPHPHits&lt;/td&gt;&#xA;          &lt;td&gt;If a TCP packet has data (which means it is not a pure ACK packet), and this packet is handled in the fast path, TcpExtTCPHPHits will increase 1&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPHystartDelayCwnd&lt;/td&gt;&#xA;          &lt;td&gt;The sum of CWND detected by packet delay. Dividing this value by TcpExtTCPHystartDelayDetect is the average CWND which detected by the packet delay&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPHystartDelayDetect&lt;/td&gt;&#xA;          &lt;td&gt;How many times the packet delay threshold is detected&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPHystartTrainCwnd&lt;/td&gt;&#xA;          &lt;td&gt;The sum of CWND detected by ACK train length. Dividing this value by TcpExtTCPHystartTrainDetect is the average CWND which detected by the ACK train length&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPHystartTrainDetect&lt;/td&gt;&#xA;          &lt;td&gt;How many times the ACK train length threshold is detected&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPKeepAlive&lt;/td&gt;&#xA;          &lt;td&gt;This counter indicates many keepalive packets were sent. The keepalive won’t be enabled by default. A userspace program could enable it by setting the SO_KEEPALIVE socket option&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPLossFailures&lt;/td&gt;&#xA;          &lt;td&gt;Number of connections that enter the TCP_CA_Loss phase and then undergo RTO timeout&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPLossProbeRecovery&lt;/td&gt;&#xA;          &lt;td&gt;A packet loss is detected and recovered by TLP&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPLossProbes&lt;/td&gt;&#xA;          &lt;td&gt;A TLP probe packet is sent&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPLossUndo&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPLostRetransmit&lt;/td&gt;&#xA;          &lt;td&gt;A SACK points out that a retransmission packet is lost again&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPMD5Failure&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPMD5NotFound&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPMD5Unexpected&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPMTUPFail&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPMTUPSuccess&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPMemoryPressures&lt;/td&gt;&#xA;          &lt;td&gt;Number of times TCP ran low on memory&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPMemoryPressuresChrono&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPMinTTLDrop&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPOFODrop&lt;/td&gt;&#xA;          &lt;td&gt;The TCP layer receives an out of order packet but doesn’t have enough memory, so drops it. Such packets won’t be counted into TcpExtTCPOFOQueue&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPOFOMerge&lt;/td&gt;&#xA;          &lt;td&gt;The received out of order packet has an overlay with the previous packet. the overlay part will be dropped. All of TcpExtTCPOFOMerge packets will also be counted into TcpExtTCPOFOQueue&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPOFOQueue&lt;/td&gt;&#xA;          &lt;td&gt;The TCP layer receives an out of order packet and has enough memory to queue it&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPOrigDataSent&lt;/td&gt;&#xA;          &lt;td&gt;Number of outgoing packets with original data (excluding retransmission but including data-in-SYN). This counter is different from TcpOutSegs because TcpOutSegs also tracks pure ACKs. TCPOrigDataSent is more useful to track the TCP retransmission rate&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPPartialUndo&lt;/td&gt;&#xA;          &lt;td&gt;Detected some erroneous retransmits, a partial ACK arrived while were fast retransmitting, so able to partially undo some of our CWND reduction&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPPureAcks&lt;/td&gt;&#xA;          &lt;td&gt;If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1, if kernel handles it in the slow path, TcpExtTCPPureAcks will increase 1&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPRcvCoalesce&lt;/td&gt;&#xA;          &lt;td&gt;When packets are received by the TCP layer and are not be read by the application, the TCP layer will try to merge them. This counter indicate how many packets are merged in such situation. If GRO is enabled, lots of packets would be merged by GRO, these packets wouldn’t be counted to TcpExtTCPRcvCoalesce&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPRcvCollapsed&lt;/td&gt;&#xA;          &lt;td&gt;This counter indicates how many skbs are freed during ‘collapse’&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPRenoFailures&lt;/td&gt;&#xA;          &lt;td&gt;Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPRenoRecovery&lt;/td&gt;&#xA;          &lt;td&gt;When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPRenoRecoveryFail&lt;/td&gt;&#xA;          &lt;td&gt;Number of connections that enter the Recovery phase and then undergo RTO&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPRenoReorder&lt;/td&gt;&#xA;          &lt;td&gt;The reorder packet is detected by fast recovery. It would only be used if SACK is disabled&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPReqQFullDoCookies&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPReqQFullDrop&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPRetransFail&lt;/td&gt;&#xA;          &lt;td&gt;The TCP stack tries to deliver a retransmission packet to lower layers but the lower layers return an error&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSACKDiscard&lt;/td&gt;&#xA;          &lt;td&gt;This counter indicates how many SACK blocks are invalid. If the invalid SACK block is caused by ACK recording, the TCP stack will only ignore it and won’t update this counter&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSACKReneging&lt;/td&gt;&#xA;          &lt;td&gt;A packet was acknowledged by SACK, but the receiver has dropped this packet, so the sender needs to retransmit this packet&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSACKReorder&lt;/td&gt;&#xA;          &lt;td&gt;The reorder packet detected by SACK&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSYNChallenge&lt;/td&gt;&#xA;          &lt;td&gt;The number of challenge acks sent in response to SYN packets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSackFailures&lt;/td&gt;&#xA;          &lt;td&gt;Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSackMerged&lt;/td&gt;&#xA;          &lt;td&gt;A skb is merged&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSackRecovery&lt;/td&gt;&#xA;          &lt;td&gt;When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSackRecoveryFail&lt;/td&gt;&#xA;          &lt;td&gt;When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSackShiftFallback&lt;/td&gt;&#xA;          &lt;td&gt;A skb should be shifted or merged, but the TCP stack doesn’t do it for some reasons&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSackShifted&lt;/td&gt;&#xA;          &lt;td&gt;A skb is shifted&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSlowStartRetrans&lt;/td&gt;&#xA;          &lt;td&gt;The TCP stack wants to retransmit a packet and the congestion control state is ‘Loss’&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSpuriousRTOs&lt;/td&gt;&#xA;          &lt;td&gt;The spurious retransmission timeout detected by the F-RTO algorithm&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSpuriousRtxHostQueues&lt;/td&gt;&#xA;          &lt;td&gt;When the TCP stack wants to retransmit a packet, and finds that packet is not lost in the network, but the packet is not sent yet, the TCP stack would give up the retransmission and update this counter. It might happen if a packet stays too long time in a qdisc or driver queue&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPSynRetrans&lt;/td&gt;&#xA;          &lt;td&gt;Number of SYN and SYN/ACK retransmits to break down retransmissions into SYN, fast-retransmits, timeout retransmits, etc&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPTSReorder&lt;/td&gt;&#xA;          &lt;td&gt;The reorder packet is detected when a hole is filled&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPTimeWaitOverflow&lt;/td&gt;&#xA;          &lt;td&gt;Number of TIME_WAIT sockets unable to be allocated due to limit exceeding&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPTimeouts&lt;/td&gt;&#xA;          &lt;td&gt;TCP timeout events&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPToZeroWindowAdv&lt;/td&gt;&#xA;          &lt;td&gt;The TCP receive window is set to zero from a no-zero value&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPWantZeroWindowAdv&lt;/td&gt;&#xA;          &lt;td&gt;Depending on current memory usage, the TCP stack tries to set receive window to zero. But the receive window might still be a no-zero value&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPWinProbe&lt;/td&gt;&#xA;          &lt;td&gt;Number of ACK packets to be sent at regular intervals to make sure a reverse ACK packet opening back a window has not been lost&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TCPWqueueTooBig&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TW&lt;/td&gt;&#xA;          &lt;td&gt;TCP sockets finished time wait in fast timer&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TWKilled&lt;/td&gt;&#xA;          &lt;td&gt;TCP sockets finished time wait in slow timer&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_TcpExt_TWRecycled&lt;/td&gt;&#xA;          &lt;td&gt;Time wait sockets recycled by time stamp&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_ActiveOpens&lt;/td&gt;&#xA;          &lt;td&gt;It means the TCP layer sends a SYN, and come into the SYN-SENT state. Every time TcpActiveOpens increases 1, TcpOutSegs should always increase 1&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_AttemptFails&lt;/td&gt;&#xA;          &lt;td&gt;The number of times TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_CurrEstab&lt;/td&gt;&#xA;          &lt;td&gt;The number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_EstabResets&lt;/td&gt;&#xA;          &lt;td&gt;The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_InCsumErrors&lt;/td&gt;&#xA;          &lt;td&gt;Incremented when a TCP checksum failure is detected&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_InErrs&lt;/td&gt;&#xA;          &lt;td&gt;The total number of segments received in error (e.g., bad TCP checksums)&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_InSegs&lt;/td&gt;&#xA;          &lt;td&gt;The number of packets received by the TCP layer. As mentioned in RFC1213, it includes the packets received in error, such as checksum error, invalid TCP header and so on&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_MaxConn&lt;/td&gt;&#xA;          &lt;td&gt;The limit on the total number of TCP connections the entity can support. In entities where the maximum number of connections is dynamic, this object should contain the value -1&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_OutRsts&lt;/td&gt;&#xA;          &lt;td&gt;The number of TCP segments sent containing the RST flag&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_OutSegs&lt;/td&gt;&#xA;          &lt;td&gt;The total number of segments sent, including those on current connections but excluding those containing only retransmitted octets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_PassiveOpens&lt;/td&gt;&#xA;          &lt;td&gt;The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_RetransSegs&lt;/td&gt;&#xA;          &lt;td&gt;The total number of segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_RtoAlgorithm&lt;/td&gt;&#xA;          &lt;td&gt;The algorithm used to determine the timeout value used for retransmitting unacknowledged octets&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_RtoMax&lt;/td&gt;&#xA;          &lt;td&gt;The maximum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;netstat_Tcp_RtoMin&lt;/td&gt;&#xA;          &lt;td&gt;The minimum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_FRAG_inuse&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_FRAG_memory&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_RAW_inuse&lt;/td&gt;&#xA;          &lt;td&gt;Number of RAW socket used&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_TCP_alloc&lt;/td&gt;&#xA;          &lt;td&gt;The number of TCP sockets that have been allocated&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_TCP_inuse&lt;/td&gt;&#xA;          &lt;td&gt;Established TCP socket number&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_TCP_mem&lt;/td&gt;&#xA;          &lt;td&gt;The total size of TCP memory used by the system&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_TCP_mem_bytes&lt;/td&gt;&#xA;          &lt;td&gt;The total size of TCP memory used by the system&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_TCP_mem * page_size&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_TCP_orphan&lt;/td&gt;&#xA;          &lt;td&gt;Number of TCP connections waiting to be closed&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_TCP_tw&lt;/td&gt;&#xA;          &lt;td&gt;Number of TCP sockets to be terminated&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_UDPLITE_inuse&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_UDP_inuse&lt;/td&gt;&#xA;          &lt;td&gt;Number of UDP socket used&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;host,container&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_UDP_mem&lt;/td&gt;&#xA;          &lt;td&gt;The total size of udp memory used by the system&lt;/td&gt;&#xA;          &lt;td&gt;pages&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_UDP_mem_bytes&lt;/td&gt;&#xA;          &lt;td&gt;The total number of bytes of udp memory used by the system&lt;/td&gt;&#xA;          &lt;td&gt;bytes&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_UDP_mem * page_size&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;network&lt;/td&gt;&#xA;          &lt;td&gt;sockstat_sockets_used&lt;/td&gt;&#xA;          &lt;td&gt;The number of sockets used by the system&lt;/td&gt;&#xA;          &lt;td&gt;count&lt;/td&gt;&#xA;          &lt;td&gt;system&lt;/td&gt;&#xA;          &lt;td&gt;proc fs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Events</title>
      <link>https://huatuo.tech/docs/en/latest/key-feature/events/</link>
      <pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://huatuo.tech/docs/en/latest/key-feature/events/</guid>
      <description>&lt;p&gt;HUATUO currently supports the following exception context capture events:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Event Name&lt;/th&gt;&#xA;          &lt;th&gt;Core Functionality&lt;/th&gt;&#xA;          &lt;th&gt;Scenarios&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;softirq&lt;/td&gt;&#xA;          &lt;td&gt;Detects delayed response or prolonged disabling of host soft interrupts, and outputs kernel call stacks and process information when soft interrupts are disabled for extended periods., etc.&lt;/td&gt;&#xA;          &lt;td&gt;This type of issue severely impacts network transmission/reception, leading to business spikes or timeout issues&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;dropwatch&lt;/td&gt;&#xA;          &lt;td&gt;Detects TCP packet loss and outputs host and network context information when packet loss occurs&lt;/td&gt;&#xA;          &lt;td&gt;This type of issue mainly causes business spikes and latency&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;net_rx_latency&lt;/td&gt;&#xA;          &lt;td&gt;Captures latency events in network receive path from driver, protocol stack, to user-space receive process&lt;/td&gt;&#xA;          &lt;td&gt;For network latency issues in the receive direction where the exact delay location is unclear, net_rx_latency calculates latency at the driver, protocol stack, and user copy paths using skb NIC ingress timestamps, filters timeout packets via preset thresholds, and locates the delay position&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;oom&lt;/td&gt;&#xA;          &lt;td&gt;Detects OOM events on the host or within containers&lt;/td&gt;&#xA;          &lt;td&gt;When OOM occurs at host level or container dimension, captures process information triggering OOM, killed process information, and container details to troubleshoot memory leaks, abnormal exits, etc.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;softlockup&lt;/td&gt;&#xA;          &lt;td&gt;When a softlockup occurs on the system, collects target process information and CPU details, and retrieves kernel stack information from all CPUs&lt;/td&gt;&#xA;          &lt;td&gt;System softlockup events&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;hungtask&lt;/td&gt;&#xA;          &lt;td&gt;Provides count of all D-state processes in the system and kernel stack information&lt;/td&gt;&#xA;          &lt;td&gt;Used to locate transient D-state process scenarios, preserving the scene for later problem tracking&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memreclaim&lt;/td&gt;&#xA;          &lt;td&gt;Records process information when memory reclamation exceeds time threshold&lt;/td&gt;&#xA;          &lt;td&gt;When memory pressure is excessively high, if a process requests memory at this time, it may enter direct reclamation (synchronous phase), potentially causing business process stalls. Recording the direct reclamation entry time helps assess the severity of impact on the process&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;netdev&lt;/td&gt;&#xA;          &lt;td&gt;Detects network device status changes&lt;/td&gt;&#xA;          &lt;td&gt;Network card flapping, slave abnormalities in bond environments, etc.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;lacp&lt;/td&gt;&#xA;          &lt;td&gt;Detects LACP status changes&lt;/td&gt;&#xA;          &lt;td&gt;Detects LACP negotiation status in bond mode 4&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;detect-the-long-term-disabling-of-soft-interrupts&#34;&gt;Detect the long-term disabling of soft interrupts&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#detect-the-long-term-disabling-of-soft-interrupts&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;Feature Introduction&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Autotracing</title>
      <link>https://huatuo.tech/docs/en/latest/key-feature/autotracing/</link>
      <pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://huatuo.tech/docs/en/latest/key-feature/autotracing/</guid>
      <description>&lt;p&gt;HUATUO currently supports automatic tracing for the following metrics:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Tracing Name&lt;/th&gt;&#xA;          &lt;th&gt;Core Function&lt;/th&gt;&#xA;          &lt;th&gt;Scenario&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpusys&lt;/td&gt;&#xA;          &lt;td&gt;Host sys surge detection&lt;/td&gt;&#xA;          &lt;td&gt;Service glitches caused by abnormal system load&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cpuidle&lt;/td&gt;&#xA;          &lt;td&gt;Container CPU idle drop detection, providing call stacks, flame graphs, process context info, etc.&lt;/td&gt;&#xA;          &lt;td&gt;Abnormal container CPU usage, helping identify process hotspots&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;dload&lt;/td&gt;&#xA;          &lt;td&gt;Tracks container loadavg and process states, automatically captures D-state process call info in containers&lt;/td&gt;&#xA;          &lt;td&gt;System D-state surges are often related to unavailable resources or long-held locks; R-state process surges often indicate poor business logic design&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;waitrate&lt;/td&gt;&#xA;          &lt;td&gt;Container resource contention detection; provides info on contending containers during scheduling conflicts&lt;/td&gt;&#xA;          &lt;td&gt;Container contention can cause service glitches; existing metrics lack specific contending container details; waitrate tracing provides this info for mixed-deployment resource isolation reference&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;memburst&lt;/td&gt;&#xA;          &lt;td&gt;Records context info during sudden memory allocations&lt;/td&gt;&#xA;          &lt;td&gt;Detects short-term, large memory allocation events on the host, which may trigger direct reclaim or OOM&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;iotracing&lt;/td&gt;&#xA;          &lt;td&gt;Detects abnormal host disk I/O latency. Outputs context info like accessed filenames/paths, disk devices, inode numbers, containers, etc.&lt;/td&gt;&#xA;          &lt;td&gt;Frequent disk I/O bandwidth saturation or access surges leading to application request latency or system performance jitter&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
  </channel>
</rss>
