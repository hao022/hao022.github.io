<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en" class="no-js" data-theme-init>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta name="color-scheme" content="light dark">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)"  content="#000000">

<style>
  html { background: Canvas; color: CanvasText; }
  @media (prefers-color-scheme: dark) {
    html { background: #0b0d12; color: #e6e6e6; }
  }
  html[data-theme-init] * { transition: none !important; }
</style>

<script>
  (function() {
    const themeKey = 'td-color-theme';
    const storedTheme = localStorage.getItem(themeKey);
    let theme = storedTheme || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');

    if (theme === 'auto') {
      theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    document.documentElement.setAttribute('data-bs-theme', theme);
  })();
</script>
<meta name="robots" content="index, follow">


<link rel="shortcut icon" href="/docs/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/docs/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/docs/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/docs/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/docs/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/docs/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/docs/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/docs/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/docs/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/docs/favicons/android-192x192.png" sizes="192x192">

<title>Metrics | HUATUO Doc</title>
<meta name="description" content="Subsystem Metric Description Unit Dimension Source cpu cpu_util_sys Time of running kernel processes percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_usr Time of running user processes percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_total Total time of running percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_sys Time of running kernel processes percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_usr Time of running user processes percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_total Total time of running percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_stat_container_burst_time Cumulative wall-time (in nanoseconds) that any CPUs has used above quota in respective periods ns container cpu.stat cpu cpu_stat_container_nr_bursts Number of periods burst occurs count container cpu.stat cpu cpu_stat_container_nr_throttled Number of times the group has been throttled/limited count container cpu.stat cpu cpu_stat_container_exter_wait_rate Wait rate caused by processes outside the container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_inner_wait_rate Wait rate caused by processes inside the container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_throttle_wait_rate Wait rate caused by throttle of container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_wait_rate Total wait rate: exter_wait_rate &#43; inner_wait_rate &#43; throttle_wait_rate % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu loadavg_container_container_nr_running The number of running tasks in the container count container get from kernel via netlink cpu loadavg_container_container_nr_uninterruptible The number of uninterruptible tasks in the container count container get from kernel via netlink cpu loadavg_load1 System load avg over the last 1 minute count host proc fs cpu loadavg_load5 System load avg over the last 5 minute count host proc fs cpu loadavg_load15 system load avg over the last 15 minute count host proc fs cpu monsoftirq_latency The number of NET_RX/NET_TX irq latency happend in the following regions:
0~10 us
100us ~ 1ms
10us ~ 100us
1ms ~ inf count host hook the softirq event and do time statistics via bpf cpu runqlat_container_nlat_01 The number of times when schedule latency of processes in the container is within 0~10ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_02 The number of times when schedule latency of processes in the container is within 10~20ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_03 The number of times when schedule latency of processes in the container is within 20~50ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_04 The number of times when schedule latency of processes in the container is more than 50ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_01 The number of times when schedule latency of processes in the host is within
0~10ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_02 The number of times when schedule latency of processes in the host is within 10~20ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_03 The number of times when schedule latency of processes in the host is within 20~50ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_04 The number of times when schedule latency of processes in the host is more than 50ms count host hook the scheduling switch event and do time statistics via bpf cpu reschedipi_oversell_probability The possibility of cpu overselling exists on the host where the vm is located 0-1 host hook the scheduling ipi event and do time statistics via bpf memory buddyinfo_blocks Kernel memory allocator information pages host proc fs memory memory_events_container_watermark_inc Counts of memory allocation watermark increasing count container memory.events memory memory_events_container_watermark_dec Counts of memory allocation watermark decreasing count container memory.events memory memory_others_container_local_direct_reclaim_time Time speed in page allocation in memory cgroup nanosecond container memory.local_direct_reclaim_time memory memory_others_container_directstall_time Memory cgroup’s direct reclaim time in try_charge nanosecond container memory.directstall_stat memory memory_others_container_asyncreclaim_time Memory cgroup’s direct reclaim time in cgroup async memory reclaim nanosecond container memory.asynreclaim_stat memory priority_reclaim_kswapd Kswapd’s reclaim stat in priority reclaiming pages host proc fs memory priority_reclaim_direct Direct reclaim stat in priority reclaiming pages host proc fs memory memory_stat_container_writeback Bytes of file/anon cache that are queued for syncing to disk bytes container memory.stat memory memory_stat_container_unevictable Bytes of memory that cannot be reclaimed (mlocked etc) bytes container memory.stat memory memory_stat_container_shmem Bytes of shmem memory bytes container memory.stat memory memory_stat_container_pgsteal_kswapd Bytes of reclaimed memory by kswapd and cswapd bytes container memory.stat memory memory_stat_container_pgsteal_globalkswapd Bytes of reclaimed memory by kswapd bytes container memory.stat memory memory_stat_container_pgsteal_globaldirect Bytes of reclaimed memory by direct reclaim during page allocation bytes container memory.stat memory memory_stat_container_pgsteal_direct Bytes of reclaimed memory by direct reclaim during page allocation and try_charge bytes container memory.stat memory memory_stat_container_pgsteal_cswapd Bytes of reclaimed memory by cswapd bytes container memory.stat memory memory_stat_container_pgscan_kswapd Bytes of scanned memory by kswapd and cswapd bytes container memory.stat memory memory_stat_container_pgscan_globalkswapd Bytes of scanned memory by kswapd bytes container memory.stat memory memory_stat_container_pgscan_globaldirect Bytes of scanned memory by direct reclaim during page allocation bytes container memory.stat memory memory_stat_container_pgscan_direct Bytes of scanned memory by direct reclaim during page allocation and try_charge bytes container memory.stat memory memory_stat_container_pgscan_cswapd Bytes of scanned memory by cswapd bytes container memory.stat memory memory_stat_container_pgrefill Bytes of memory that is scanned in active list bytes container memory.stat memory memory_stat_container_pgdeactivate Bytes of memory that is deactivated into inactive list bytes container memory.stat memory memory_stat_container_inactive_file Bytes of file-backed memory on inactive lru list. bytes container memory.stat memory memory_stat_container_inactive_anon Bytes of anonymous and swap cache memory on inactive lru list bytes container memory.stat memory memory_stat_container_dirty Bytes that are waiting to get written back to the disk bytes container memory.stat memory memory_stat_container_active_file Bytes of file-backed memory on active lru list bytes container memory.stat memory memory_stat_container_active_anon Bytes of anonymous and swap cache memory on active lru list bytes container memory.stat memory mountpoint_perm_ro Whether mountpoint is readonly or not bool host proc fs memory vmstat_allocstall_normal Host direct reclaim count on normal zone count host /proc/vmstat memory vmstat_allocstall_movable Host direct reclaim count on movable zone count host /proc/vmstat memory vmstat_compact_stall Count of memory compaction count host /proc/vmstat memory vmstat_nr_active_anon Number of anonymous pages on active lru pages host /proc/vmstat memory vmstat_nr_active_file Number of file-backed pages on active lru pages host /proc/vmstat memory vmstat_nr_boost_pages Number of pages in kswapd boosting pages host /proc/vmstat memory vmstat_nr_dirty Number of dirty pages pages host /proc/vmstat memory vmstat_nr_free_pages Number of free pages pages host /proc/vmstat memory vmstat_nr_inactive_anon Number of anonymous pages on inactive lru pages host /proc/vmstat memory vmstat_nr_inactive_file Number of file-backed pages on inactive lru pages host /proc/vmstat memory vmstat_nr_kswapd_boost Count of kswapd boosting pages host /proc/vmstat memory vmstat_nr_mlock Number of locked pages pages host /proc/vmstat memory vmstat_nr_shmem Number of shmem pages pages host /proc/vmstat memory vmstat_nr_slab_reclaimable Number of relcaimable slab pages pages host /proc/vmstat memory vmstat_nr_slab_unreclaimable Number of unrelcaimable slab pages pages host /proc/vmstat memory vmstat_nr_unevictable Number of unevictable pages pages host /proc/vmstat memory vmstat_nr_writeback Number of writebacking pages pages host /proc/vmstat memory vmstat_numa_pages_migrated Number of pages in numa migrating pages host /proc/vmstat memory vmstat_pgdeactivate Number of pages which are deactivated into inactive lru pages host /proc/vmstat memory vmstat_pgrefill Number of pages which are scanned on active lru pages host /proc/vmstat memory vmstat_pgscan_direct Number of pages which are scanned in direct reclaim pages host /proc/vmstat memory vmstat_pgscan_kswapd Number of pages which are scanned in kswapd reclaim pages host /proc/vmstat memory vmstat_pgsteal_direct Number of pages which are reclaimed in direct reclaim pages host /proc/vmstat memory vmstat_pgsteal_kswapd Number of pages which are reclaimed in kswapd reclaim pages host /proc/vmstat memory hungtask_happened Count of hungtask events count host performance and statistics monitoring for BPF Programs memory oom_happened Count of oom events count host,container performance and statistics monitoring for BPF Programs memory softlockup_happened Count of softlockup events count host performance and statistics monitoring for BPF Programs memory mmhostbpf_compactionstat Time speed in memory compaction nanosecond host performance and statistics monitoring for BPF Programs memory mmhostbpf_allocstallstat Time speed in memory direct reclaim on host nanosecond host performance and statistics monitoring for BPF Programs memory mmcgroupbpf_container_directstallcount Count of cgroup’s try_charge direct reclaim count container performance and statistics monitoring for BPF Programs IO iolatency_disk_d2c Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components count host performance and statistics monitoring for BPF Programs IO iolatency_disk_q2c Statistics of io latency for the entire io lifecycle when accessing the disk count host performance and statistics monitoring for BPF Programs IO iolatency_container_d2c Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components count container performance and statistics monitoring for BPF Programs IO iolatency_container_q2c Statistics of io latency for the entire io lifecycle when accessing the disk count container performance and statistics monitoring for BPF Programs IO iolatency_disk_flush Statistics of delay for flush operations on disk raid device count host performance and statistics monitoring for BPF Programs IO iolatency_container_flush Statistics of delay for flush operations on disk raid devices caused by containers count container performance and statistics monitoring for BPF Programs IO iolatency_disk_freeze Statistics of disk freeze events count host performance and statistics monitoring for BPF Programs network tcp_mem_limit_pages System TCP total memory size limit pages system proc fs network tcp_mem_usage_bytes The total number of bytes of TCP memory used by the system bytes system tcp_mem_usage_pages * page_size network tcp_mem_usage_pages The total size of TCP memory used by the system pages system proc fs network tcp_mem_usage_percent The percentage of TCP memory used by the system to the limit size % system tcp_mem_usage_pages / tcp_mem_limit_pages network arp_entries The number of arp cache entries count host,container proc fs network arp_total Total number of arp cache entries count system proc fs network qdisc_backlog The number of bytes queued to be sent bytes host sum of same level(parent major) for a device network qdisc_bytes_total The number of bytes sent bytes host sum of same level(parent major) for a device network qdisc_current_queue_length The number of packets queued for sending count host sum of same level(parent major) for a device network qdisc_drops_total The number of discarded packets count host sum of same level(parent major) for a device network qdisc_overlimits_total The number of queued packets exceeds the limit count host sum of same level(parent major) for a device network qdisc_packets_total The number of packets sent count host sum of same level(parent major) for a device network qdisc_requeues_total The number of packets that were not sent successfully and were requeued count host sum of same level(parent major) for a device network ethtool_hardware_rx_dropped_errors Statistics of inbound packet droped or errors of interface count host related to hardware drivers, such as mlx, ixgbe, bnxt_en, etc. network netdev_receive_bytes_total Number of good received bytes bytes host,container proc fs network netdev_receive_compressed_total Number of correctly received compressed packets count host,container proc fs network netdev_receive_dropped_total Number of packets received but not processed count host,container proc fs network netdev_receive_errors_total Total number of bad packets received on this network device count host,container proc fs network netdev_receive_fifo_total Receiver FIFO error counter count host,container proc fs network netdev_receive_frame_total Receiver frame alignment errors count host,container proc fs network netdev_receive_multicast_total Multicast packets received. For hardware interfaces this statistic is commonly calculated at the device level (unlike rx_packets) and therefore may include packets which did not reach the host count host,container proc fs network netdev_receive_packets_total Number of good packets received by the interface count host,container proc fs network netdev_transmit_bytes_total Number of good transmitted bytes, corresponding to tx_packets bytes host,container proc fs network netdev_transmit_carrier_total Number of frame transmission errors due to loss of carrier during transmission count host,container proc fs network netdev_transmit_colls_total Number of collisions during packet transmissions count host,container proc fs network netdev_transmit_compressed_total Number of transmitted compressed packets count host,container proc fs network netdev_transmit_dropped_total Number of packets dropped on their way to transmission, e.g. due to lack of resources count host,container proc fs network netdev_transmit_errors_total Total number of transmit problems count host,container proc fs network netdev_transmit_fifo_total Number of frame transmission errors due to device FIFO underrun / underflow count host,container proc fs network netdev_transmit_packets_total Number of packets successfully transmitted count host,container proc fs network netstat_TcpExt_ArpFilter - count host,container proc fs network netstat_TcpExt_BusyPollRxPackets - count host,container proc fs network netstat_TcpExt_DelayedACKLocked A delayed ACK timer expires, but the TCP stack can’t send an ACK immediately due to the socket is locked by a userspace program. The TCP stack will send a pure ACK later (after the userspace program unlock the socket). When the TCP stack sends the pure ACK later, the TCP stack will also update TcpExtDelayedACKs and exit the delayed ACK mode count host,container proc fs network netstat_TcpExt_DelayedACKLost It will be updated when the TCP stack receives a packet which has been ACKed. A Delayed ACK loss might cause this issue, but it would also be triggered by other reasons, such as a packet is duplicated in the network count host,container proc fs network netstat_TcpExt_DelayedACKs A delayed ACK timer expires. The TCP stack will send a pure ACK packet and exit the delayed ACK mode count host,container proc fs network netstat_TcpExt_EmbryonicRsts resets received for embryonic SYN_RECV sockets count host,container proc fs network netstat_TcpExt_IPReversePathFilter - count host,container proc fs network netstat_TcpExt_ListenDrops When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase count host,container proc fs network netstat_TcpExt_ListenOverflows When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase count host,container proc fs network netstat_TcpExt_LockDroppedIcmps ICMP packets dropped because socket was locked count host,container proc fs network netstat_TcpExt_OfoPruned The TCP stack tries to discard packet on the out of order queue count host,container proc fs network netstat_TcpExt_OutOfWindowIcmps ICMP pkts dropped because they were out-of-window count host,container proc fs network netstat_TcpExt_PAWSActive Packets are dropped by PAWS in Syn-Sent status count host,container proc fs network netstat_TcpExt_PAWSEstab Packets are dropped by PAWS in any status other than Syn-Sent count host,container proc fs network netstat_TcpExt_PFMemallocDrop - count host,container proc fs network netstat_TcpExt_PruneCalled The TCP stack tries to reclaim memory for a socket. After updates this counter, the TCP stack will try to collapse the out of order queue and the receiving queue. If the memory is still not enough, the TCP stack will try to discard packets from the out of order queue (and update the TcpExtOfoPruned counter) count host,container proc fs network netstat_TcpExt_RcvPruned After ‘collapse’ and discard packets from the out of order queue, if the actually used memory is still larger than the max allowed memory, this counter will be updated. It means the ‘prune’ fails count host,container proc fs network netstat_TcpExt_SyncookiesFailed The MSS decoded from the SYN cookie is invalid. When this counter is updated, the received packet won’t be treated as a SYN cookie and the TcpExtSyncookiesRecv counter won’t be updated count host,container proc fs network netstat_TcpExt_SyncookiesRecv How many reply packets of the SYN cookies the TCP stack receives count host,container proc fs network netstat_TcpExt_SyncookiesSent It indicates how many SYN cookies are sent count host,container proc fs network netstat_TcpExt_TCPACKSkippedChallenge The ACK is skipped if the ACK is a challenge ACK count host,container proc fs network netstat_TcpExt_TCPACKSkippedFinWait2 The ACK is skipped in Fin-Wait-2 status, the reason would be either PAWS check fails or the received sequence number is out of window count host,container proc fs network netstat_TcpExt_TCPACKSkippedPAWS The ACK is skipped due to PAWS (Protect Against Wrapped Sequence numbers) check fails count host,container proc fs network netstat_TcpExt_TCPACKSkippedSeq The sequence number is out of window and the timestamp passes the PAWS check and the TCP status is not Syn-Recv, Fin-Wait-2, and Time-Wait count host,container proc fs network netstat_TcpExt_TCPACKSkippedSynRecv The ACK is skipped in Syn-Recv status. The Syn-Recv status means the TCP stack receives a SYN and replies SYN&#43;ACK count host,container proc fs network netstat_TcpExt_TCPACKSkippedTimeWait The ACK is skipped in Time-Wait status, the reason would be either PAWS check failed or the received sequence number is out of window count host,container proc fs network netstat_TcpExt_TCPAbortFailed The kernel TCP layer will send RST if the RFC2525 2.17 section is satisfied. If an internal error occurs during this process, TcpExtTCPAbortFailed will be increased count host,container proc fs network netstat_TcpExt_TCPAbortOnClose Number of sockets closed when the user-mode program has data in the buffer count host,container proc fs network netstat_TcpExt_TCPAbortOnData It means TCP layer has data in flight, but need to close the connection count host,container proc fs network netstat_TcpExt_TCPAbortOnLinger When a TCP connection comes into FIN_WAIT_2 state, instead of waiting for the fin packet from the other side, kernel could send a RST and delete the socket immediately count host,container proc fs network netstat_TcpExt_TCPAbortOnMemory When an application closes a TCP connection, kernel still need to track the connection, let it complete the TCP disconnect process count host,container proc fs network netstat_TcpExt_TCPAbortOnTimeout This counter will increase when any of the TCP timers expire. In such situation, kernel won’t send RST, just give up the connection count host,container proc fs network netstat_TcpExt_TCPAckCompressed - count host,container proc fs network netstat_TcpExt_TCPAutoCorking When sending packets, the TCP layer will try to merge small packets to a bigger one count host,container proc fs network netstat_TcpExt_TCPBacklogDrop - count host,container proc fs network netstat_TcpExt_TCPChallengeACK The number of challenge acks sent count host,container proc fs network netstat_TcpExt_TCPDSACKIgnoredNoUndo When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket count host,container proc fs network netstat_TcpExt_TCPDSACKIgnoredOld When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket count host,container proc fs network netstat_TcpExt_TCPDSACKOfoRecv The TCP stack receives a DSACK, which indicate an out of order duplicate packet is received count host,container proc fs network netstat_TcpExt_TCPDSACKOfoSent The TCP stack receives an out of order duplicate packet, so it sends a DSACK to the sender count host,container proc fs network netstat_TcpExt_TCPDSACKOldSent The TCP stack receives a duplicate packet which has been acked, so it sends a DSACK to the sender count host,container proc fs network netstat_TcpExt_TCPDSACKRecv The TCP stack receives a DSACK, which indicates an acknowledged duplicate packet is received count host,container proc fs network netstat_TcpExt_TCPDSACKUndo Congestion window recovered without slow start using DSACK count host,container proc fs network netstat_TcpExt_TCPDeferAcceptDrop - count host,container proc fs network netstat_TcpExt_TCPDelivered - count host,container proc fs network netstat_TcpExt_TCPDeliveredCE - count host,container proc fs network netstat_TcpExt_TCPFastOpenActive When the TCP stack receives an ACK packet in the SYN-SENT status, and the ACK packet acknowledges the data in the SYN packet, the TCP stack understand the TFO cookie is accepted by the other side, then it updates this counter count host,container proc fs network netstat_TcpExt_TCPFastOpenActiveFail Fast Open attempts (SYN/data) failed because the remote does not accept it or the attempts timed out count host,container proc fs network netstat_TcpExt_TCPFastOpenBlackhole - count host,container proc fs network netstat_TcpExt_TCPFastOpenCookieReqd This counter indicates how many times a client wants to request a TFO cookie count host,container proc fs network netstat_TcpExt_TCPFastOpenListenOverflow When the pending fast open request number is larger than fastopenq-&gt;max_qlen, the TCP stack will reject the fast open request and update this counter count host,container proc fs network netstat_TcpExt_TCPFastOpenPassive This counter indicates how many times the TCP stack accepts the fast open request count host,container proc fs network netstat_TcpExt_TCPFastOpenPassiveFail This counter indicates how many times the TCP stack rejects the fast open request. It is caused by either the TFO cookie is invalid or the TCP stack finds an error during the socket creating process count host,container proc fs network netstat_TcpExt_TCPFastRetrans The TCP stack wants to retransmit a packet and the congestion control state is not ‘Loss’ count host,container proc fs network netstat_TcpExt_TCPFromZeroWindowAdv The TCP receive window is set to no-zero value from zero count host,container proc fs network netstat_TcpExt_TCPFullUndo - count host,container proc fs network netstat_TcpExt_TCPHPAcks If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1 count host,container proc fs network netstat_TcpExt_TCPHPHits If a TCP packet has data (which means it is not a pure ACK packet), and this packet is handled in the fast path, TcpExtTCPHPHits will increase 1 count host,container proc fs network netstat_TcpExt_TCPHystartDelayCwnd The sum of CWND detected by packet delay. Dividing this value by TcpExtTCPHystartDelayDetect is the average CWND which detected by the packet delay count host,container proc fs network netstat_TcpExt_TCPHystartDelayDetect How many times the packet delay threshold is detected count host,container proc fs network netstat_TcpExt_TCPHystartTrainCwnd The sum of CWND detected by ACK train length. Dividing this value by TcpExtTCPHystartTrainDetect is the average CWND which detected by the ACK train length count host,container proc fs network netstat_TcpExt_TCPHystartTrainDetect How many times the ACK train length threshold is detected count host,container proc fs network netstat_TcpExt_TCPKeepAlive This counter indicates many keepalive packets were sent. The keepalive won’t be enabled by default. A userspace program could enable it by setting the SO_KEEPALIVE socket option count host,container proc fs network netstat_TcpExt_TCPLossFailures Number of connections that enter the TCP_CA_Loss phase and then undergo RTO timeout count host,container proc fs network netstat_TcpExt_TCPLossProbeRecovery A packet loss is detected and recovered by TLP count host,container proc fs network netstat_TcpExt_TCPLossProbes A TLP probe packet is sent count host,container proc fs network netstat_TcpExt_TCPLossUndo - count host,container proc fs network netstat_TcpExt_TCPLostRetransmit A SACK points out that a retransmission packet is lost again count host,container proc fs network netstat_TcpExt_TCPMD5Failure - count host,container proc fs network netstat_TcpExt_TCPMD5NotFound - count host,container proc fs network netstat_TcpExt_TCPMD5Unexpected - count host,container proc fs network netstat_TcpExt_TCPMTUPFail - count host,container proc fs network netstat_TcpExt_TCPMTUPSuccess - count host,container proc fs network netstat_TcpExt_TCPMemoryPressures Number of times TCP ran low on memory count host,container proc fs network netstat_TcpExt_TCPMemoryPressuresChrono - count host,container proc fs network netstat_TcpExt_TCPMinTTLDrop - count host,container proc fs network netstat_TcpExt_TCPOFODrop The TCP layer receives an out of order packet but doesn’t have enough memory, so drops it. Such packets won’t be counted into TcpExtTCPOFOQueue count host,container proc fs network netstat_TcpExt_TCPOFOMerge The received out of order packet has an overlay with the previous packet. the overlay part will be dropped. All of TcpExtTCPOFOMerge packets will also be counted into TcpExtTCPOFOQueue count host,container proc fs network netstat_TcpExt_TCPOFOQueue The TCP layer receives an out of order packet and has enough memory to queue it count host,container proc fs network netstat_TcpExt_TCPOrigDataSent Number of outgoing packets with original data (excluding retransmission but including data-in-SYN). This counter is different from TcpOutSegs because TcpOutSegs also tracks pure ACKs. TCPOrigDataSent is more useful to track the TCP retransmission rate count host,container proc fs network netstat_TcpExt_TCPPartialUndo Detected some erroneous retransmits, a partial ACK arrived while were fast retransmitting, so able to partially undo some of our CWND reduction count host,container proc fs network netstat_TcpExt_TCPPureAcks If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1, if kernel handles it in the slow path, TcpExtTCPPureAcks will increase 1 count host,container proc fs network netstat_TcpExt_TCPRcvCoalesce When packets are received by the TCP layer and are not be read by the application, the TCP layer will try to merge them. This counter indicate how many packets are merged in such situation. If GRO is enabled, lots of packets would be merged by GRO, these packets wouldn’t be counted to TcpExtTCPRcvCoalesce count host,container proc fs network netstat_TcpExt_TCPRcvCollapsed This counter indicates how many skbs are freed during ‘collapse’ count host,container proc fs network netstat_TcpExt_TCPRenoFailures Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPRenoRecovery When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets count host,container proc fs network netstat_TcpExt_TCPRenoRecoveryFail Number of connections that enter the Recovery phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPRenoReorder The reorder packet is detected by fast recovery. It would only be used if SACK is disabled count host,container proc fs network netstat_TcpExt_TCPReqQFullDoCookies - count host,container proc fs network netstat_TcpExt_TCPReqQFullDrop - count host,container proc fs network netstat_TcpExt_TCPRetransFail The TCP stack tries to deliver a retransmission packet to lower layers but the lower layers return an error count host,container proc fs network netstat_TcpExt_TCPSACKDiscard This counter indicates how many SACK blocks are invalid. If the invalid SACK block is caused by ACK recording, the TCP stack will only ignore it and won’t update this counter count host,container proc fs network netstat_TcpExt_TCPSACKReneging A packet was acknowledged by SACK, but the receiver has dropped this packet, so the sender needs to retransmit this packet count host,container proc fs network netstat_TcpExt_TCPSACKReorder The reorder packet detected by SACK count host,container proc fs network netstat_TcpExt_TCPSYNChallenge The number of challenge acks sent in response to SYN packets count host,container proc fs network netstat_TcpExt_TCPSackFailures Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPSackMerged A skb is merged count host,container proc fs network netstat_TcpExt_TCPSackRecovery When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets count host,container proc fs network netstat_TcpExt_TCPSackRecoveryFail When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1 count host,container proc fs network netstat_TcpExt_TCPSackShiftFallback A skb should be shifted or merged, but the TCP stack doesn’t do it for some reasons count host,container proc fs network netstat_TcpExt_TCPSackShifted A skb is shifted count host,container proc fs network netstat_TcpExt_TCPSlowStartRetrans The TCP stack wants to retransmit a packet and the congestion control state is ‘Loss’ count host,container proc fs network netstat_TcpExt_TCPSpuriousRTOs The spurious retransmission timeout detected by the F-RTO algorithm count host,container proc fs network netstat_TcpExt_TCPSpuriousRtxHostQueues When the TCP stack wants to retransmit a packet, and finds that packet is not lost in the network, but the packet is not sent yet, the TCP stack would give up the retransmission and update this counter. It might happen if a packet stays too long time in a qdisc or driver queue count host,container proc fs network netstat_TcpExt_TCPSynRetrans Number of SYN and SYN/ACK retransmits to break down retransmissions into SYN, fast-retransmits, timeout retransmits, etc count host,container proc fs network netstat_TcpExt_TCPTSReorder The reorder packet is detected when a hole is filled count host,container proc fs network netstat_TcpExt_TCPTimeWaitOverflow Number of TIME_WAIT sockets unable to be allocated due to limit exceeding count host,container proc fs network netstat_TcpExt_TCPTimeouts TCP timeout events count host,container proc fs network netstat_TcpExt_TCPToZeroWindowAdv The TCP receive window is set to zero from a no-zero value count host,container proc fs network netstat_TcpExt_TCPWantZeroWindowAdv Depending on current memory usage, the TCP stack tries to set receive window to zero. But the receive window might still be a no-zero value count host,container proc fs network netstat_TcpExt_TCPWinProbe Number of ACK packets to be sent at regular intervals to make sure a reverse ACK packet opening back a window has not been lost count host,container proc fs network netstat_TcpExt_TCPWqueueTooBig - count host,container proc fs network netstat_TcpExt_TW TCP sockets finished time wait in fast timer count host,container proc fs network netstat_TcpExt_TWKilled TCP sockets finished time wait in slow timer count host,container proc fs network netstat_TcpExt_TWRecycled Time wait sockets recycled by time stamp count host,container proc fs network netstat_Tcp_ActiveOpens It means the TCP layer sends a SYN, and come into the SYN-SENT state. Every time TcpActiveOpens increases 1, TcpOutSegs should always increase 1 count host,container proc fs network netstat_Tcp_AttemptFails The number of times TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state count host,container proc fs network netstat_Tcp_CurrEstab The number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT count host,container proc fs network netstat_Tcp_EstabResets The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state count host,container proc fs network netstat_Tcp_InCsumErrors Incremented when a TCP checksum failure is detected count host,container proc fs network netstat_Tcp_InErrs The total number of segments received in error (e.g., bad TCP checksums) count host,container proc fs network netstat_Tcp_InSegs The number of packets received by the TCP layer. As mentioned in RFC1213, it includes the packets received in error, such as checksum error, invalid TCP header and so on count host,container proc fs network netstat_Tcp_MaxConn The limit on the total number of TCP connections the entity can support. In entities where the maximum number of connections is dynamic, this object should contain the value -1 count host,container proc fs network netstat_Tcp_OutRsts The number of TCP segments sent containing the RST flag count host,container proc fs network netstat_Tcp_OutSegs The total number of segments sent, including those on current connections but excluding those containing only retransmitted octets count host,container proc fs network netstat_Tcp_PassiveOpens The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state count host,container proc fs network netstat_Tcp_RetransSegs The total number of segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets count host,container proc fs network netstat_Tcp_RtoAlgorithm The algorithm used to determine the timeout value used for retransmitting unacknowledged octets count host,container proc fs network netstat_Tcp_RtoMax The maximum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout count host,container proc fs network netstat_Tcp_RtoMin The minimum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout count host,container proc fs network sockstat_FRAG_inuse - count host,container proc fs network sockstat_FRAG_memory - pages host,container proc fs network sockstat_RAW_inuse Number of RAW socket used count host,container proc fs network sockstat_TCP_alloc The number of TCP sockets that have been allocated count host,container proc fs network sockstat_TCP_inuse Established TCP socket number count host,container proc fs network sockstat_TCP_mem The total size of TCP memory used by the system pages system proc fs network sockstat_TCP_mem_bytes The total size of TCP memory used by the system bytes system sockstat_TCP_mem * page_size network sockstat_TCP_orphan Number of TCP connections waiting to be closed count host,container proc fs network sockstat_TCP_tw Number of TCP sockets to be terminated count host,container proc fs network sockstat_UDPLITE_inuse - count host,container proc fs network sockstat_UDP_inuse Number of UDP socket used count host,container proc fs network sockstat_UDP_mem The total size of udp memory used by the system pages system proc fs network sockstat_UDP_mem_bytes The total number of bytes of udp memory used by the system bytes system sockstat_UDP_mem * page_size network sockstat_sockets_used The number of sockets used by the system count system proc fs">
<meta property="og:url" content="https://huatuo.tech/docs/en/latest/key-feature/metrics/">
  <meta property="og:site_name" content="HUATUO Doc">
  <meta property="og:title" content="Metrics">
  <meta property="og:description" content="Subsystem Metric Description Unit Dimension Source cpu cpu_util_sys Time of running kernel processes percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_usr Time of running user processes percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_total Total time of running percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_sys Time of running kernel processes percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_usr Time of running user processes percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_total Total time of running percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_stat_container_burst_time Cumulative wall-time (in nanoseconds) that any CPUs has used above quota in respective periods ns container cpu.stat cpu cpu_stat_container_nr_bursts Number of periods burst occurs count container cpu.stat cpu cpu_stat_container_nr_throttled Number of times the group has been throttled/limited count container cpu.stat cpu cpu_stat_container_exter_wait_rate Wait rate caused by processes outside the container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_inner_wait_rate Wait rate caused by processes inside the container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_throttle_wait_rate Wait rate caused by throttle of container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_wait_rate Total wait rate: exter_wait_rate &#43; inner_wait_rate &#43; throttle_wait_rate % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu loadavg_container_container_nr_running The number of running tasks in the container count container get from kernel via netlink cpu loadavg_container_container_nr_uninterruptible The number of uninterruptible tasks in the container count container get from kernel via netlink cpu loadavg_load1 System load avg over the last 1 minute count host proc fs cpu loadavg_load5 System load avg over the last 5 minute count host proc fs cpu loadavg_load15 system load avg over the last 15 minute count host proc fs cpu monsoftirq_latency The number of NET_RX/NET_TX irq latency happend in the following regions:
0~10 us
100us ~ 1ms
10us ~ 100us
1ms ~ inf count host hook the softirq event and do time statistics via bpf cpu runqlat_container_nlat_01 The number of times when schedule latency of processes in the container is within 0~10ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_02 The number of times when schedule latency of processes in the container is within 10~20ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_03 The number of times when schedule latency of processes in the container is within 20~50ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_04 The number of times when schedule latency of processes in the container is more than 50ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_01 The number of times when schedule latency of processes in the host is within
0~10ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_02 The number of times when schedule latency of processes in the host is within 10~20ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_03 The number of times when schedule latency of processes in the host is within 20~50ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_04 The number of times when schedule latency of processes in the host is more than 50ms count host hook the scheduling switch event and do time statistics via bpf cpu reschedipi_oversell_probability The possibility of cpu overselling exists on the host where the vm is located 0-1 host hook the scheduling ipi event and do time statistics via bpf memory buddyinfo_blocks Kernel memory allocator information pages host proc fs memory memory_events_container_watermark_inc Counts of memory allocation watermark increasing count container memory.events memory memory_events_container_watermark_dec Counts of memory allocation watermark decreasing count container memory.events memory memory_others_container_local_direct_reclaim_time Time speed in page allocation in memory cgroup nanosecond container memory.local_direct_reclaim_time memory memory_others_container_directstall_time Memory cgroup’s direct reclaim time in try_charge nanosecond container memory.directstall_stat memory memory_others_container_asyncreclaim_time Memory cgroup’s direct reclaim time in cgroup async memory reclaim nanosecond container memory.asynreclaim_stat memory priority_reclaim_kswapd Kswapd’s reclaim stat in priority reclaiming pages host proc fs memory priority_reclaim_direct Direct reclaim stat in priority reclaiming pages host proc fs memory memory_stat_container_writeback Bytes of file/anon cache that are queued for syncing to disk bytes container memory.stat memory memory_stat_container_unevictable Bytes of memory that cannot be reclaimed (mlocked etc) bytes container memory.stat memory memory_stat_container_shmem Bytes of shmem memory bytes container memory.stat memory memory_stat_container_pgsteal_kswapd Bytes of reclaimed memory by kswapd and cswapd bytes container memory.stat memory memory_stat_container_pgsteal_globalkswapd Bytes of reclaimed memory by kswapd bytes container memory.stat memory memory_stat_container_pgsteal_globaldirect Bytes of reclaimed memory by direct reclaim during page allocation bytes container memory.stat memory memory_stat_container_pgsteal_direct Bytes of reclaimed memory by direct reclaim during page allocation and try_charge bytes container memory.stat memory memory_stat_container_pgsteal_cswapd Bytes of reclaimed memory by cswapd bytes container memory.stat memory memory_stat_container_pgscan_kswapd Bytes of scanned memory by kswapd and cswapd bytes container memory.stat memory memory_stat_container_pgscan_globalkswapd Bytes of scanned memory by kswapd bytes container memory.stat memory memory_stat_container_pgscan_globaldirect Bytes of scanned memory by direct reclaim during page allocation bytes container memory.stat memory memory_stat_container_pgscan_direct Bytes of scanned memory by direct reclaim during page allocation and try_charge bytes container memory.stat memory memory_stat_container_pgscan_cswapd Bytes of scanned memory by cswapd bytes container memory.stat memory memory_stat_container_pgrefill Bytes of memory that is scanned in active list bytes container memory.stat memory memory_stat_container_pgdeactivate Bytes of memory that is deactivated into inactive list bytes container memory.stat memory memory_stat_container_inactive_file Bytes of file-backed memory on inactive lru list. bytes container memory.stat memory memory_stat_container_inactive_anon Bytes of anonymous and swap cache memory on inactive lru list bytes container memory.stat memory memory_stat_container_dirty Bytes that are waiting to get written back to the disk bytes container memory.stat memory memory_stat_container_active_file Bytes of file-backed memory on active lru list bytes container memory.stat memory memory_stat_container_active_anon Bytes of anonymous and swap cache memory on active lru list bytes container memory.stat memory mountpoint_perm_ro Whether mountpoint is readonly or not bool host proc fs memory vmstat_allocstall_normal Host direct reclaim count on normal zone count host /proc/vmstat memory vmstat_allocstall_movable Host direct reclaim count on movable zone count host /proc/vmstat memory vmstat_compact_stall Count of memory compaction count host /proc/vmstat memory vmstat_nr_active_anon Number of anonymous pages on active lru pages host /proc/vmstat memory vmstat_nr_active_file Number of file-backed pages on active lru pages host /proc/vmstat memory vmstat_nr_boost_pages Number of pages in kswapd boosting pages host /proc/vmstat memory vmstat_nr_dirty Number of dirty pages pages host /proc/vmstat memory vmstat_nr_free_pages Number of free pages pages host /proc/vmstat memory vmstat_nr_inactive_anon Number of anonymous pages on inactive lru pages host /proc/vmstat memory vmstat_nr_inactive_file Number of file-backed pages on inactive lru pages host /proc/vmstat memory vmstat_nr_kswapd_boost Count of kswapd boosting pages host /proc/vmstat memory vmstat_nr_mlock Number of locked pages pages host /proc/vmstat memory vmstat_nr_shmem Number of shmem pages pages host /proc/vmstat memory vmstat_nr_slab_reclaimable Number of relcaimable slab pages pages host /proc/vmstat memory vmstat_nr_slab_unreclaimable Number of unrelcaimable slab pages pages host /proc/vmstat memory vmstat_nr_unevictable Number of unevictable pages pages host /proc/vmstat memory vmstat_nr_writeback Number of writebacking pages pages host /proc/vmstat memory vmstat_numa_pages_migrated Number of pages in numa migrating pages host /proc/vmstat memory vmstat_pgdeactivate Number of pages which are deactivated into inactive lru pages host /proc/vmstat memory vmstat_pgrefill Number of pages which are scanned on active lru pages host /proc/vmstat memory vmstat_pgscan_direct Number of pages which are scanned in direct reclaim pages host /proc/vmstat memory vmstat_pgscan_kswapd Number of pages which are scanned in kswapd reclaim pages host /proc/vmstat memory vmstat_pgsteal_direct Number of pages which are reclaimed in direct reclaim pages host /proc/vmstat memory vmstat_pgsteal_kswapd Number of pages which are reclaimed in kswapd reclaim pages host /proc/vmstat memory hungtask_happened Count of hungtask events count host performance and statistics monitoring for BPF Programs memory oom_happened Count of oom events count host,container performance and statistics monitoring for BPF Programs memory softlockup_happened Count of softlockup events count host performance and statistics monitoring for BPF Programs memory mmhostbpf_compactionstat Time speed in memory compaction nanosecond host performance and statistics monitoring for BPF Programs memory mmhostbpf_allocstallstat Time speed in memory direct reclaim on host nanosecond host performance and statistics monitoring for BPF Programs memory mmcgroupbpf_container_directstallcount Count of cgroup’s try_charge direct reclaim count container performance and statistics monitoring for BPF Programs IO iolatency_disk_d2c Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components count host performance and statistics monitoring for BPF Programs IO iolatency_disk_q2c Statistics of io latency for the entire io lifecycle when accessing the disk count host performance and statistics monitoring for BPF Programs IO iolatency_container_d2c Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components count container performance and statistics monitoring for BPF Programs IO iolatency_container_q2c Statistics of io latency for the entire io lifecycle when accessing the disk count container performance and statistics monitoring for BPF Programs IO iolatency_disk_flush Statistics of delay for flush operations on disk raid device count host performance and statistics monitoring for BPF Programs IO iolatency_container_flush Statistics of delay for flush operations on disk raid devices caused by containers count container performance and statistics monitoring for BPF Programs IO iolatency_disk_freeze Statistics of disk freeze events count host performance and statistics monitoring for BPF Programs network tcp_mem_limit_pages System TCP total memory size limit pages system proc fs network tcp_mem_usage_bytes The total number of bytes of TCP memory used by the system bytes system tcp_mem_usage_pages * page_size network tcp_mem_usage_pages The total size of TCP memory used by the system pages system proc fs network tcp_mem_usage_percent The percentage of TCP memory used by the system to the limit size % system tcp_mem_usage_pages / tcp_mem_limit_pages network arp_entries The number of arp cache entries count host,container proc fs network arp_total Total number of arp cache entries count system proc fs network qdisc_backlog The number of bytes queued to be sent bytes host sum of same level(parent major) for a device network qdisc_bytes_total The number of bytes sent bytes host sum of same level(parent major) for a device network qdisc_current_queue_length The number of packets queued for sending count host sum of same level(parent major) for a device network qdisc_drops_total The number of discarded packets count host sum of same level(parent major) for a device network qdisc_overlimits_total The number of queued packets exceeds the limit count host sum of same level(parent major) for a device network qdisc_packets_total The number of packets sent count host sum of same level(parent major) for a device network qdisc_requeues_total The number of packets that were not sent successfully and were requeued count host sum of same level(parent major) for a device network ethtool_hardware_rx_dropped_errors Statistics of inbound packet droped or errors of interface count host related to hardware drivers, such as mlx, ixgbe, bnxt_en, etc. network netdev_receive_bytes_total Number of good received bytes bytes host,container proc fs network netdev_receive_compressed_total Number of correctly received compressed packets count host,container proc fs network netdev_receive_dropped_total Number of packets received but not processed count host,container proc fs network netdev_receive_errors_total Total number of bad packets received on this network device count host,container proc fs network netdev_receive_fifo_total Receiver FIFO error counter count host,container proc fs network netdev_receive_frame_total Receiver frame alignment errors count host,container proc fs network netdev_receive_multicast_total Multicast packets received. For hardware interfaces this statistic is commonly calculated at the device level (unlike rx_packets) and therefore may include packets which did not reach the host count host,container proc fs network netdev_receive_packets_total Number of good packets received by the interface count host,container proc fs network netdev_transmit_bytes_total Number of good transmitted bytes, corresponding to tx_packets bytes host,container proc fs network netdev_transmit_carrier_total Number of frame transmission errors due to loss of carrier during transmission count host,container proc fs network netdev_transmit_colls_total Number of collisions during packet transmissions count host,container proc fs network netdev_transmit_compressed_total Number of transmitted compressed packets count host,container proc fs network netdev_transmit_dropped_total Number of packets dropped on their way to transmission, e.g. due to lack of resources count host,container proc fs network netdev_transmit_errors_total Total number of transmit problems count host,container proc fs network netdev_transmit_fifo_total Number of frame transmission errors due to device FIFO underrun / underflow count host,container proc fs network netdev_transmit_packets_total Number of packets successfully transmitted count host,container proc fs network netstat_TcpExt_ArpFilter - count host,container proc fs network netstat_TcpExt_BusyPollRxPackets - count host,container proc fs network netstat_TcpExt_DelayedACKLocked A delayed ACK timer expires, but the TCP stack can’t send an ACK immediately due to the socket is locked by a userspace program. The TCP stack will send a pure ACK later (after the userspace program unlock the socket). When the TCP stack sends the pure ACK later, the TCP stack will also update TcpExtDelayedACKs and exit the delayed ACK mode count host,container proc fs network netstat_TcpExt_DelayedACKLost It will be updated when the TCP stack receives a packet which has been ACKed. A Delayed ACK loss might cause this issue, but it would also be triggered by other reasons, such as a packet is duplicated in the network count host,container proc fs network netstat_TcpExt_DelayedACKs A delayed ACK timer expires. The TCP stack will send a pure ACK packet and exit the delayed ACK mode count host,container proc fs network netstat_TcpExt_EmbryonicRsts resets received for embryonic SYN_RECV sockets count host,container proc fs network netstat_TcpExt_IPReversePathFilter - count host,container proc fs network netstat_TcpExt_ListenDrops When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase count host,container proc fs network netstat_TcpExt_ListenOverflows When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase count host,container proc fs network netstat_TcpExt_LockDroppedIcmps ICMP packets dropped because socket was locked count host,container proc fs network netstat_TcpExt_OfoPruned The TCP stack tries to discard packet on the out of order queue count host,container proc fs network netstat_TcpExt_OutOfWindowIcmps ICMP pkts dropped because they were out-of-window count host,container proc fs network netstat_TcpExt_PAWSActive Packets are dropped by PAWS in Syn-Sent status count host,container proc fs network netstat_TcpExt_PAWSEstab Packets are dropped by PAWS in any status other than Syn-Sent count host,container proc fs network netstat_TcpExt_PFMemallocDrop - count host,container proc fs network netstat_TcpExt_PruneCalled The TCP stack tries to reclaim memory for a socket. After updates this counter, the TCP stack will try to collapse the out of order queue and the receiving queue. If the memory is still not enough, the TCP stack will try to discard packets from the out of order queue (and update the TcpExtOfoPruned counter) count host,container proc fs network netstat_TcpExt_RcvPruned After ‘collapse’ and discard packets from the out of order queue, if the actually used memory is still larger than the max allowed memory, this counter will be updated. It means the ‘prune’ fails count host,container proc fs network netstat_TcpExt_SyncookiesFailed The MSS decoded from the SYN cookie is invalid. When this counter is updated, the received packet won’t be treated as a SYN cookie and the TcpExtSyncookiesRecv counter won’t be updated count host,container proc fs network netstat_TcpExt_SyncookiesRecv How many reply packets of the SYN cookies the TCP stack receives count host,container proc fs network netstat_TcpExt_SyncookiesSent It indicates how many SYN cookies are sent count host,container proc fs network netstat_TcpExt_TCPACKSkippedChallenge The ACK is skipped if the ACK is a challenge ACK count host,container proc fs network netstat_TcpExt_TCPACKSkippedFinWait2 The ACK is skipped in Fin-Wait-2 status, the reason would be either PAWS check fails or the received sequence number is out of window count host,container proc fs network netstat_TcpExt_TCPACKSkippedPAWS The ACK is skipped due to PAWS (Protect Against Wrapped Sequence numbers) check fails count host,container proc fs network netstat_TcpExt_TCPACKSkippedSeq The sequence number is out of window and the timestamp passes the PAWS check and the TCP status is not Syn-Recv, Fin-Wait-2, and Time-Wait count host,container proc fs network netstat_TcpExt_TCPACKSkippedSynRecv The ACK is skipped in Syn-Recv status. The Syn-Recv status means the TCP stack receives a SYN and replies SYN&#43;ACK count host,container proc fs network netstat_TcpExt_TCPACKSkippedTimeWait The ACK is skipped in Time-Wait status, the reason would be either PAWS check failed or the received sequence number is out of window count host,container proc fs network netstat_TcpExt_TCPAbortFailed The kernel TCP layer will send RST if the RFC2525 2.17 section is satisfied. If an internal error occurs during this process, TcpExtTCPAbortFailed will be increased count host,container proc fs network netstat_TcpExt_TCPAbortOnClose Number of sockets closed when the user-mode program has data in the buffer count host,container proc fs network netstat_TcpExt_TCPAbortOnData It means TCP layer has data in flight, but need to close the connection count host,container proc fs network netstat_TcpExt_TCPAbortOnLinger When a TCP connection comes into FIN_WAIT_2 state, instead of waiting for the fin packet from the other side, kernel could send a RST and delete the socket immediately count host,container proc fs network netstat_TcpExt_TCPAbortOnMemory When an application closes a TCP connection, kernel still need to track the connection, let it complete the TCP disconnect process count host,container proc fs network netstat_TcpExt_TCPAbortOnTimeout This counter will increase when any of the TCP timers expire. In such situation, kernel won’t send RST, just give up the connection count host,container proc fs network netstat_TcpExt_TCPAckCompressed - count host,container proc fs network netstat_TcpExt_TCPAutoCorking When sending packets, the TCP layer will try to merge small packets to a bigger one count host,container proc fs network netstat_TcpExt_TCPBacklogDrop - count host,container proc fs network netstat_TcpExt_TCPChallengeACK The number of challenge acks sent count host,container proc fs network netstat_TcpExt_TCPDSACKIgnoredNoUndo When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket count host,container proc fs network netstat_TcpExt_TCPDSACKIgnoredOld When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket count host,container proc fs network netstat_TcpExt_TCPDSACKOfoRecv The TCP stack receives a DSACK, which indicate an out of order duplicate packet is received count host,container proc fs network netstat_TcpExt_TCPDSACKOfoSent The TCP stack receives an out of order duplicate packet, so it sends a DSACK to the sender count host,container proc fs network netstat_TcpExt_TCPDSACKOldSent The TCP stack receives a duplicate packet which has been acked, so it sends a DSACK to the sender count host,container proc fs network netstat_TcpExt_TCPDSACKRecv The TCP stack receives a DSACK, which indicates an acknowledged duplicate packet is received count host,container proc fs network netstat_TcpExt_TCPDSACKUndo Congestion window recovered without slow start using DSACK count host,container proc fs network netstat_TcpExt_TCPDeferAcceptDrop - count host,container proc fs network netstat_TcpExt_TCPDelivered - count host,container proc fs network netstat_TcpExt_TCPDeliveredCE - count host,container proc fs network netstat_TcpExt_TCPFastOpenActive When the TCP stack receives an ACK packet in the SYN-SENT status, and the ACK packet acknowledges the data in the SYN packet, the TCP stack understand the TFO cookie is accepted by the other side, then it updates this counter count host,container proc fs network netstat_TcpExt_TCPFastOpenActiveFail Fast Open attempts (SYN/data) failed because the remote does not accept it or the attempts timed out count host,container proc fs network netstat_TcpExt_TCPFastOpenBlackhole - count host,container proc fs network netstat_TcpExt_TCPFastOpenCookieReqd This counter indicates how many times a client wants to request a TFO cookie count host,container proc fs network netstat_TcpExt_TCPFastOpenListenOverflow When the pending fast open request number is larger than fastopenq-&gt;max_qlen, the TCP stack will reject the fast open request and update this counter count host,container proc fs network netstat_TcpExt_TCPFastOpenPassive This counter indicates how many times the TCP stack accepts the fast open request count host,container proc fs network netstat_TcpExt_TCPFastOpenPassiveFail This counter indicates how many times the TCP stack rejects the fast open request. It is caused by either the TFO cookie is invalid or the TCP stack finds an error during the socket creating process count host,container proc fs network netstat_TcpExt_TCPFastRetrans The TCP stack wants to retransmit a packet and the congestion control state is not ‘Loss’ count host,container proc fs network netstat_TcpExt_TCPFromZeroWindowAdv The TCP receive window is set to no-zero value from zero count host,container proc fs network netstat_TcpExt_TCPFullUndo - count host,container proc fs network netstat_TcpExt_TCPHPAcks If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1 count host,container proc fs network netstat_TcpExt_TCPHPHits If a TCP packet has data (which means it is not a pure ACK packet), and this packet is handled in the fast path, TcpExtTCPHPHits will increase 1 count host,container proc fs network netstat_TcpExt_TCPHystartDelayCwnd The sum of CWND detected by packet delay. Dividing this value by TcpExtTCPHystartDelayDetect is the average CWND which detected by the packet delay count host,container proc fs network netstat_TcpExt_TCPHystartDelayDetect How many times the packet delay threshold is detected count host,container proc fs network netstat_TcpExt_TCPHystartTrainCwnd The sum of CWND detected by ACK train length. Dividing this value by TcpExtTCPHystartTrainDetect is the average CWND which detected by the ACK train length count host,container proc fs network netstat_TcpExt_TCPHystartTrainDetect How many times the ACK train length threshold is detected count host,container proc fs network netstat_TcpExt_TCPKeepAlive This counter indicates many keepalive packets were sent. The keepalive won’t be enabled by default. A userspace program could enable it by setting the SO_KEEPALIVE socket option count host,container proc fs network netstat_TcpExt_TCPLossFailures Number of connections that enter the TCP_CA_Loss phase and then undergo RTO timeout count host,container proc fs network netstat_TcpExt_TCPLossProbeRecovery A packet loss is detected and recovered by TLP count host,container proc fs network netstat_TcpExt_TCPLossProbes A TLP probe packet is sent count host,container proc fs network netstat_TcpExt_TCPLossUndo - count host,container proc fs network netstat_TcpExt_TCPLostRetransmit A SACK points out that a retransmission packet is lost again count host,container proc fs network netstat_TcpExt_TCPMD5Failure - count host,container proc fs network netstat_TcpExt_TCPMD5NotFound - count host,container proc fs network netstat_TcpExt_TCPMD5Unexpected - count host,container proc fs network netstat_TcpExt_TCPMTUPFail - count host,container proc fs network netstat_TcpExt_TCPMTUPSuccess - count host,container proc fs network netstat_TcpExt_TCPMemoryPressures Number of times TCP ran low on memory count host,container proc fs network netstat_TcpExt_TCPMemoryPressuresChrono - count host,container proc fs network netstat_TcpExt_TCPMinTTLDrop - count host,container proc fs network netstat_TcpExt_TCPOFODrop The TCP layer receives an out of order packet but doesn’t have enough memory, so drops it. Such packets won’t be counted into TcpExtTCPOFOQueue count host,container proc fs network netstat_TcpExt_TCPOFOMerge The received out of order packet has an overlay with the previous packet. the overlay part will be dropped. All of TcpExtTCPOFOMerge packets will also be counted into TcpExtTCPOFOQueue count host,container proc fs network netstat_TcpExt_TCPOFOQueue The TCP layer receives an out of order packet and has enough memory to queue it count host,container proc fs network netstat_TcpExt_TCPOrigDataSent Number of outgoing packets with original data (excluding retransmission but including data-in-SYN). This counter is different from TcpOutSegs because TcpOutSegs also tracks pure ACKs. TCPOrigDataSent is more useful to track the TCP retransmission rate count host,container proc fs network netstat_TcpExt_TCPPartialUndo Detected some erroneous retransmits, a partial ACK arrived while were fast retransmitting, so able to partially undo some of our CWND reduction count host,container proc fs network netstat_TcpExt_TCPPureAcks If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1, if kernel handles it in the slow path, TcpExtTCPPureAcks will increase 1 count host,container proc fs network netstat_TcpExt_TCPRcvCoalesce When packets are received by the TCP layer and are not be read by the application, the TCP layer will try to merge them. This counter indicate how many packets are merged in such situation. If GRO is enabled, lots of packets would be merged by GRO, these packets wouldn’t be counted to TcpExtTCPRcvCoalesce count host,container proc fs network netstat_TcpExt_TCPRcvCollapsed This counter indicates how many skbs are freed during ‘collapse’ count host,container proc fs network netstat_TcpExt_TCPRenoFailures Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPRenoRecovery When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets count host,container proc fs network netstat_TcpExt_TCPRenoRecoveryFail Number of connections that enter the Recovery phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPRenoReorder The reorder packet is detected by fast recovery. It would only be used if SACK is disabled count host,container proc fs network netstat_TcpExt_TCPReqQFullDoCookies - count host,container proc fs network netstat_TcpExt_TCPReqQFullDrop - count host,container proc fs network netstat_TcpExt_TCPRetransFail The TCP stack tries to deliver a retransmission packet to lower layers but the lower layers return an error count host,container proc fs network netstat_TcpExt_TCPSACKDiscard This counter indicates how many SACK blocks are invalid. If the invalid SACK block is caused by ACK recording, the TCP stack will only ignore it and won’t update this counter count host,container proc fs network netstat_TcpExt_TCPSACKReneging A packet was acknowledged by SACK, but the receiver has dropped this packet, so the sender needs to retransmit this packet count host,container proc fs network netstat_TcpExt_TCPSACKReorder The reorder packet detected by SACK count host,container proc fs network netstat_TcpExt_TCPSYNChallenge The number of challenge acks sent in response to SYN packets count host,container proc fs network netstat_TcpExt_TCPSackFailures Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPSackMerged A skb is merged count host,container proc fs network netstat_TcpExt_TCPSackRecovery When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets count host,container proc fs network netstat_TcpExt_TCPSackRecoveryFail When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1 count host,container proc fs network netstat_TcpExt_TCPSackShiftFallback A skb should be shifted or merged, but the TCP stack doesn’t do it for some reasons count host,container proc fs network netstat_TcpExt_TCPSackShifted A skb is shifted count host,container proc fs network netstat_TcpExt_TCPSlowStartRetrans The TCP stack wants to retransmit a packet and the congestion control state is ‘Loss’ count host,container proc fs network netstat_TcpExt_TCPSpuriousRTOs The spurious retransmission timeout detected by the F-RTO algorithm count host,container proc fs network netstat_TcpExt_TCPSpuriousRtxHostQueues When the TCP stack wants to retransmit a packet, and finds that packet is not lost in the network, but the packet is not sent yet, the TCP stack would give up the retransmission and update this counter. It might happen if a packet stays too long time in a qdisc or driver queue count host,container proc fs network netstat_TcpExt_TCPSynRetrans Number of SYN and SYN/ACK retransmits to break down retransmissions into SYN, fast-retransmits, timeout retransmits, etc count host,container proc fs network netstat_TcpExt_TCPTSReorder The reorder packet is detected when a hole is filled count host,container proc fs network netstat_TcpExt_TCPTimeWaitOverflow Number of TIME_WAIT sockets unable to be allocated due to limit exceeding count host,container proc fs network netstat_TcpExt_TCPTimeouts TCP timeout events count host,container proc fs network netstat_TcpExt_TCPToZeroWindowAdv The TCP receive window is set to zero from a no-zero value count host,container proc fs network netstat_TcpExt_TCPWantZeroWindowAdv Depending on current memory usage, the TCP stack tries to set receive window to zero. But the receive window might still be a no-zero value count host,container proc fs network netstat_TcpExt_TCPWinProbe Number of ACK packets to be sent at regular intervals to make sure a reverse ACK packet opening back a window has not been lost count host,container proc fs network netstat_TcpExt_TCPWqueueTooBig - count host,container proc fs network netstat_TcpExt_TW TCP sockets finished time wait in fast timer count host,container proc fs network netstat_TcpExt_TWKilled TCP sockets finished time wait in slow timer count host,container proc fs network netstat_TcpExt_TWRecycled Time wait sockets recycled by time stamp count host,container proc fs network netstat_Tcp_ActiveOpens It means the TCP layer sends a SYN, and come into the SYN-SENT state. Every time TcpActiveOpens increases 1, TcpOutSegs should always increase 1 count host,container proc fs network netstat_Tcp_AttemptFails The number of times TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state count host,container proc fs network netstat_Tcp_CurrEstab The number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT count host,container proc fs network netstat_Tcp_EstabResets The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state count host,container proc fs network netstat_Tcp_InCsumErrors Incremented when a TCP checksum failure is detected count host,container proc fs network netstat_Tcp_InErrs The total number of segments received in error (e.g., bad TCP checksums) count host,container proc fs network netstat_Tcp_InSegs The number of packets received by the TCP layer. As mentioned in RFC1213, it includes the packets received in error, such as checksum error, invalid TCP header and so on count host,container proc fs network netstat_Tcp_MaxConn The limit on the total number of TCP connections the entity can support. In entities where the maximum number of connections is dynamic, this object should contain the value -1 count host,container proc fs network netstat_Tcp_OutRsts The number of TCP segments sent containing the RST flag count host,container proc fs network netstat_Tcp_OutSegs The total number of segments sent, including those on current connections but excluding those containing only retransmitted octets count host,container proc fs network netstat_Tcp_PassiveOpens The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state count host,container proc fs network netstat_Tcp_RetransSegs The total number of segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets count host,container proc fs network netstat_Tcp_RtoAlgorithm The algorithm used to determine the timeout value used for retransmitting unacknowledged octets count host,container proc fs network netstat_Tcp_RtoMax The maximum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout count host,container proc fs network netstat_Tcp_RtoMin The minimum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout count host,container proc fs network sockstat_FRAG_inuse - count host,container proc fs network sockstat_FRAG_memory - pages host,container proc fs network sockstat_RAW_inuse Number of RAW socket used count host,container proc fs network sockstat_TCP_alloc The number of TCP sockets that have been allocated count host,container proc fs network sockstat_TCP_inuse Established TCP socket number count host,container proc fs network sockstat_TCP_mem The total size of TCP memory used by the system pages system proc fs network sockstat_TCP_mem_bytes The total size of TCP memory used by the system bytes system sockstat_TCP_mem * page_size network sockstat_TCP_orphan Number of TCP connections waiting to be closed count host,container proc fs network sockstat_TCP_tw Number of TCP sockets to be terminated count host,container proc fs network sockstat_UDPLITE_inuse - count host,container proc fs network sockstat_UDP_inuse Number of UDP socket used count host,container proc fs network sockstat_UDP_mem The total size of udp memory used by the system pages system proc fs network sockstat_UDP_mem_bytes The total number of bytes of udp memory used by the system bytes system sockstat_UDP_mem * page_size network sockstat_sockets_used The number of sockets used by the system count system proc fs">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="latest">
    <meta property="article:published_time" content="2026-01-11T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-11T00:00:00+00:00">

  <meta itemprop="name" content="Metrics">
  <meta itemprop="description" content="Subsystem Metric Description Unit Dimension Source cpu cpu_util_sys Time of running kernel processes percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_usr Time of running user processes percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_total Total time of running percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_sys Time of running kernel processes percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_usr Time of running user processes percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_total Total time of running percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_stat_container_burst_time Cumulative wall-time (in nanoseconds) that any CPUs has used above quota in respective periods ns container cpu.stat cpu cpu_stat_container_nr_bursts Number of periods burst occurs count container cpu.stat cpu cpu_stat_container_nr_throttled Number of times the group has been throttled/limited count container cpu.stat cpu cpu_stat_container_exter_wait_rate Wait rate caused by processes outside the container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_inner_wait_rate Wait rate caused by processes inside the container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_throttle_wait_rate Wait rate caused by throttle of container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_wait_rate Total wait rate: exter_wait_rate &#43; inner_wait_rate &#43; throttle_wait_rate % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu loadavg_container_container_nr_running The number of running tasks in the container count container get from kernel via netlink cpu loadavg_container_container_nr_uninterruptible The number of uninterruptible tasks in the container count container get from kernel via netlink cpu loadavg_load1 System load avg over the last 1 minute count host proc fs cpu loadavg_load5 System load avg over the last 5 minute count host proc fs cpu loadavg_load15 system load avg over the last 15 minute count host proc fs cpu monsoftirq_latency The number of NET_RX/NET_TX irq latency happend in the following regions:
0~10 us
100us ~ 1ms
10us ~ 100us
1ms ~ inf count host hook the softirq event and do time statistics via bpf cpu runqlat_container_nlat_01 The number of times when schedule latency of processes in the container is within 0~10ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_02 The number of times when schedule latency of processes in the container is within 10~20ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_03 The number of times when schedule latency of processes in the container is within 20~50ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_04 The number of times when schedule latency of processes in the container is more than 50ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_01 The number of times when schedule latency of processes in the host is within
0~10ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_02 The number of times when schedule latency of processes in the host is within 10~20ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_03 The number of times when schedule latency of processes in the host is within 20~50ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_04 The number of times when schedule latency of processes in the host is more than 50ms count host hook the scheduling switch event and do time statistics via bpf cpu reschedipi_oversell_probability The possibility of cpu overselling exists on the host where the vm is located 0-1 host hook the scheduling ipi event and do time statistics via bpf memory buddyinfo_blocks Kernel memory allocator information pages host proc fs memory memory_events_container_watermark_inc Counts of memory allocation watermark increasing count container memory.events memory memory_events_container_watermark_dec Counts of memory allocation watermark decreasing count container memory.events memory memory_others_container_local_direct_reclaim_time Time speed in page allocation in memory cgroup nanosecond container memory.local_direct_reclaim_time memory memory_others_container_directstall_time Memory cgroup’s direct reclaim time in try_charge nanosecond container memory.directstall_stat memory memory_others_container_asyncreclaim_time Memory cgroup’s direct reclaim time in cgroup async memory reclaim nanosecond container memory.asynreclaim_stat memory priority_reclaim_kswapd Kswapd’s reclaim stat in priority reclaiming pages host proc fs memory priority_reclaim_direct Direct reclaim stat in priority reclaiming pages host proc fs memory memory_stat_container_writeback Bytes of file/anon cache that are queued for syncing to disk bytes container memory.stat memory memory_stat_container_unevictable Bytes of memory that cannot be reclaimed (mlocked etc) bytes container memory.stat memory memory_stat_container_shmem Bytes of shmem memory bytes container memory.stat memory memory_stat_container_pgsteal_kswapd Bytes of reclaimed memory by kswapd and cswapd bytes container memory.stat memory memory_stat_container_pgsteal_globalkswapd Bytes of reclaimed memory by kswapd bytes container memory.stat memory memory_stat_container_pgsteal_globaldirect Bytes of reclaimed memory by direct reclaim during page allocation bytes container memory.stat memory memory_stat_container_pgsteal_direct Bytes of reclaimed memory by direct reclaim during page allocation and try_charge bytes container memory.stat memory memory_stat_container_pgsteal_cswapd Bytes of reclaimed memory by cswapd bytes container memory.stat memory memory_stat_container_pgscan_kswapd Bytes of scanned memory by kswapd and cswapd bytes container memory.stat memory memory_stat_container_pgscan_globalkswapd Bytes of scanned memory by kswapd bytes container memory.stat memory memory_stat_container_pgscan_globaldirect Bytes of scanned memory by direct reclaim during page allocation bytes container memory.stat memory memory_stat_container_pgscan_direct Bytes of scanned memory by direct reclaim during page allocation and try_charge bytes container memory.stat memory memory_stat_container_pgscan_cswapd Bytes of scanned memory by cswapd bytes container memory.stat memory memory_stat_container_pgrefill Bytes of memory that is scanned in active list bytes container memory.stat memory memory_stat_container_pgdeactivate Bytes of memory that is deactivated into inactive list bytes container memory.stat memory memory_stat_container_inactive_file Bytes of file-backed memory on inactive lru list. bytes container memory.stat memory memory_stat_container_inactive_anon Bytes of anonymous and swap cache memory on inactive lru list bytes container memory.stat memory memory_stat_container_dirty Bytes that are waiting to get written back to the disk bytes container memory.stat memory memory_stat_container_active_file Bytes of file-backed memory on active lru list bytes container memory.stat memory memory_stat_container_active_anon Bytes of anonymous and swap cache memory on active lru list bytes container memory.stat memory mountpoint_perm_ro Whether mountpoint is readonly or not bool host proc fs memory vmstat_allocstall_normal Host direct reclaim count on normal zone count host /proc/vmstat memory vmstat_allocstall_movable Host direct reclaim count on movable zone count host /proc/vmstat memory vmstat_compact_stall Count of memory compaction count host /proc/vmstat memory vmstat_nr_active_anon Number of anonymous pages on active lru pages host /proc/vmstat memory vmstat_nr_active_file Number of file-backed pages on active lru pages host /proc/vmstat memory vmstat_nr_boost_pages Number of pages in kswapd boosting pages host /proc/vmstat memory vmstat_nr_dirty Number of dirty pages pages host /proc/vmstat memory vmstat_nr_free_pages Number of free pages pages host /proc/vmstat memory vmstat_nr_inactive_anon Number of anonymous pages on inactive lru pages host /proc/vmstat memory vmstat_nr_inactive_file Number of file-backed pages on inactive lru pages host /proc/vmstat memory vmstat_nr_kswapd_boost Count of kswapd boosting pages host /proc/vmstat memory vmstat_nr_mlock Number of locked pages pages host /proc/vmstat memory vmstat_nr_shmem Number of shmem pages pages host /proc/vmstat memory vmstat_nr_slab_reclaimable Number of relcaimable slab pages pages host /proc/vmstat memory vmstat_nr_slab_unreclaimable Number of unrelcaimable slab pages pages host /proc/vmstat memory vmstat_nr_unevictable Number of unevictable pages pages host /proc/vmstat memory vmstat_nr_writeback Number of writebacking pages pages host /proc/vmstat memory vmstat_numa_pages_migrated Number of pages in numa migrating pages host /proc/vmstat memory vmstat_pgdeactivate Number of pages which are deactivated into inactive lru pages host /proc/vmstat memory vmstat_pgrefill Number of pages which are scanned on active lru pages host /proc/vmstat memory vmstat_pgscan_direct Number of pages which are scanned in direct reclaim pages host /proc/vmstat memory vmstat_pgscan_kswapd Number of pages which are scanned in kswapd reclaim pages host /proc/vmstat memory vmstat_pgsteal_direct Number of pages which are reclaimed in direct reclaim pages host /proc/vmstat memory vmstat_pgsteal_kswapd Number of pages which are reclaimed in kswapd reclaim pages host /proc/vmstat memory hungtask_happened Count of hungtask events count host performance and statistics monitoring for BPF Programs memory oom_happened Count of oom events count host,container performance and statistics monitoring for BPF Programs memory softlockup_happened Count of softlockup events count host performance and statistics monitoring for BPF Programs memory mmhostbpf_compactionstat Time speed in memory compaction nanosecond host performance and statistics monitoring for BPF Programs memory mmhostbpf_allocstallstat Time speed in memory direct reclaim on host nanosecond host performance and statistics monitoring for BPF Programs memory mmcgroupbpf_container_directstallcount Count of cgroup’s try_charge direct reclaim count container performance and statistics monitoring for BPF Programs IO iolatency_disk_d2c Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components count host performance and statistics monitoring for BPF Programs IO iolatency_disk_q2c Statistics of io latency for the entire io lifecycle when accessing the disk count host performance and statistics monitoring for BPF Programs IO iolatency_container_d2c Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components count container performance and statistics monitoring for BPF Programs IO iolatency_container_q2c Statistics of io latency for the entire io lifecycle when accessing the disk count container performance and statistics monitoring for BPF Programs IO iolatency_disk_flush Statistics of delay for flush operations on disk raid device count host performance and statistics monitoring for BPF Programs IO iolatency_container_flush Statistics of delay for flush operations on disk raid devices caused by containers count container performance and statistics monitoring for BPF Programs IO iolatency_disk_freeze Statistics of disk freeze events count host performance and statistics monitoring for BPF Programs network tcp_mem_limit_pages System TCP total memory size limit pages system proc fs network tcp_mem_usage_bytes The total number of bytes of TCP memory used by the system bytes system tcp_mem_usage_pages * page_size network tcp_mem_usage_pages The total size of TCP memory used by the system pages system proc fs network tcp_mem_usage_percent The percentage of TCP memory used by the system to the limit size % system tcp_mem_usage_pages / tcp_mem_limit_pages network arp_entries The number of arp cache entries count host,container proc fs network arp_total Total number of arp cache entries count system proc fs network qdisc_backlog The number of bytes queued to be sent bytes host sum of same level(parent major) for a device network qdisc_bytes_total The number of bytes sent bytes host sum of same level(parent major) for a device network qdisc_current_queue_length The number of packets queued for sending count host sum of same level(parent major) for a device network qdisc_drops_total The number of discarded packets count host sum of same level(parent major) for a device network qdisc_overlimits_total The number of queued packets exceeds the limit count host sum of same level(parent major) for a device network qdisc_packets_total The number of packets sent count host sum of same level(parent major) for a device network qdisc_requeues_total The number of packets that were not sent successfully and were requeued count host sum of same level(parent major) for a device network ethtool_hardware_rx_dropped_errors Statistics of inbound packet droped or errors of interface count host related to hardware drivers, such as mlx, ixgbe, bnxt_en, etc. network netdev_receive_bytes_total Number of good received bytes bytes host,container proc fs network netdev_receive_compressed_total Number of correctly received compressed packets count host,container proc fs network netdev_receive_dropped_total Number of packets received but not processed count host,container proc fs network netdev_receive_errors_total Total number of bad packets received on this network device count host,container proc fs network netdev_receive_fifo_total Receiver FIFO error counter count host,container proc fs network netdev_receive_frame_total Receiver frame alignment errors count host,container proc fs network netdev_receive_multicast_total Multicast packets received. For hardware interfaces this statistic is commonly calculated at the device level (unlike rx_packets) and therefore may include packets which did not reach the host count host,container proc fs network netdev_receive_packets_total Number of good packets received by the interface count host,container proc fs network netdev_transmit_bytes_total Number of good transmitted bytes, corresponding to tx_packets bytes host,container proc fs network netdev_transmit_carrier_total Number of frame transmission errors due to loss of carrier during transmission count host,container proc fs network netdev_transmit_colls_total Number of collisions during packet transmissions count host,container proc fs network netdev_transmit_compressed_total Number of transmitted compressed packets count host,container proc fs network netdev_transmit_dropped_total Number of packets dropped on their way to transmission, e.g. due to lack of resources count host,container proc fs network netdev_transmit_errors_total Total number of transmit problems count host,container proc fs network netdev_transmit_fifo_total Number of frame transmission errors due to device FIFO underrun / underflow count host,container proc fs network netdev_transmit_packets_total Number of packets successfully transmitted count host,container proc fs network netstat_TcpExt_ArpFilter - count host,container proc fs network netstat_TcpExt_BusyPollRxPackets - count host,container proc fs network netstat_TcpExt_DelayedACKLocked A delayed ACK timer expires, but the TCP stack can’t send an ACK immediately due to the socket is locked by a userspace program. The TCP stack will send a pure ACK later (after the userspace program unlock the socket). When the TCP stack sends the pure ACK later, the TCP stack will also update TcpExtDelayedACKs and exit the delayed ACK mode count host,container proc fs network netstat_TcpExt_DelayedACKLost It will be updated when the TCP stack receives a packet which has been ACKed. A Delayed ACK loss might cause this issue, but it would also be triggered by other reasons, such as a packet is duplicated in the network count host,container proc fs network netstat_TcpExt_DelayedACKs A delayed ACK timer expires. The TCP stack will send a pure ACK packet and exit the delayed ACK mode count host,container proc fs network netstat_TcpExt_EmbryonicRsts resets received for embryonic SYN_RECV sockets count host,container proc fs network netstat_TcpExt_IPReversePathFilter - count host,container proc fs network netstat_TcpExt_ListenDrops When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase count host,container proc fs network netstat_TcpExt_ListenOverflows When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase count host,container proc fs network netstat_TcpExt_LockDroppedIcmps ICMP packets dropped because socket was locked count host,container proc fs network netstat_TcpExt_OfoPruned The TCP stack tries to discard packet on the out of order queue count host,container proc fs network netstat_TcpExt_OutOfWindowIcmps ICMP pkts dropped because they were out-of-window count host,container proc fs network netstat_TcpExt_PAWSActive Packets are dropped by PAWS in Syn-Sent status count host,container proc fs network netstat_TcpExt_PAWSEstab Packets are dropped by PAWS in any status other than Syn-Sent count host,container proc fs network netstat_TcpExt_PFMemallocDrop - count host,container proc fs network netstat_TcpExt_PruneCalled The TCP stack tries to reclaim memory for a socket. After updates this counter, the TCP stack will try to collapse the out of order queue and the receiving queue. If the memory is still not enough, the TCP stack will try to discard packets from the out of order queue (and update the TcpExtOfoPruned counter) count host,container proc fs network netstat_TcpExt_RcvPruned After ‘collapse’ and discard packets from the out of order queue, if the actually used memory is still larger than the max allowed memory, this counter will be updated. It means the ‘prune’ fails count host,container proc fs network netstat_TcpExt_SyncookiesFailed The MSS decoded from the SYN cookie is invalid. When this counter is updated, the received packet won’t be treated as a SYN cookie and the TcpExtSyncookiesRecv counter won’t be updated count host,container proc fs network netstat_TcpExt_SyncookiesRecv How many reply packets of the SYN cookies the TCP stack receives count host,container proc fs network netstat_TcpExt_SyncookiesSent It indicates how many SYN cookies are sent count host,container proc fs network netstat_TcpExt_TCPACKSkippedChallenge The ACK is skipped if the ACK is a challenge ACK count host,container proc fs network netstat_TcpExt_TCPACKSkippedFinWait2 The ACK is skipped in Fin-Wait-2 status, the reason would be either PAWS check fails or the received sequence number is out of window count host,container proc fs network netstat_TcpExt_TCPACKSkippedPAWS The ACK is skipped due to PAWS (Protect Against Wrapped Sequence numbers) check fails count host,container proc fs network netstat_TcpExt_TCPACKSkippedSeq The sequence number is out of window and the timestamp passes the PAWS check and the TCP status is not Syn-Recv, Fin-Wait-2, and Time-Wait count host,container proc fs network netstat_TcpExt_TCPACKSkippedSynRecv The ACK is skipped in Syn-Recv status. The Syn-Recv status means the TCP stack receives a SYN and replies SYN&#43;ACK count host,container proc fs network netstat_TcpExt_TCPACKSkippedTimeWait The ACK is skipped in Time-Wait status, the reason would be either PAWS check failed or the received sequence number is out of window count host,container proc fs network netstat_TcpExt_TCPAbortFailed The kernel TCP layer will send RST if the RFC2525 2.17 section is satisfied. If an internal error occurs during this process, TcpExtTCPAbortFailed will be increased count host,container proc fs network netstat_TcpExt_TCPAbortOnClose Number of sockets closed when the user-mode program has data in the buffer count host,container proc fs network netstat_TcpExt_TCPAbortOnData It means TCP layer has data in flight, but need to close the connection count host,container proc fs network netstat_TcpExt_TCPAbortOnLinger When a TCP connection comes into FIN_WAIT_2 state, instead of waiting for the fin packet from the other side, kernel could send a RST and delete the socket immediately count host,container proc fs network netstat_TcpExt_TCPAbortOnMemory When an application closes a TCP connection, kernel still need to track the connection, let it complete the TCP disconnect process count host,container proc fs network netstat_TcpExt_TCPAbortOnTimeout This counter will increase when any of the TCP timers expire. In such situation, kernel won’t send RST, just give up the connection count host,container proc fs network netstat_TcpExt_TCPAckCompressed - count host,container proc fs network netstat_TcpExt_TCPAutoCorking When sending packets, the TCP layer will try to merge small packets to a bigger one count host,container proc fs network netstat_TcpExt_TCPBacklogDrop - count host,container proc fs network netstat_TcpExt_TCPChallengeACK The number of challenge acks sent count host,container proc fs network netstat_TcpExt_TCPDSACKIgnoredNoUndo When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket count host,container proc fs network netstat_TcpExt_TCPDSACKIgnoredOld When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket count host,container proc fs network netstat_TcpExt_TCPDSACKOfoRecv The TCP stack receives a DSACK, which indicate an out of order duplicate packet is received count host,container proc fs network netstat_TcpExt_TCPDSACKOfoSent The TCP stack receives an out of order duplicate packet, so it sends a DSACK to the sender count host,container proc fs network netstat_TcpExt_TCPDSACKOldSent The TCP stack receives a duplicate packet which has been acked, so it sends a DSACK to the sender count host,container proc fs network netstat_TcpExt_TCPDSACKRecv The TCP stack receives a DSACK, which indicates an acknowledged duplicate packet is received count host,container proc fs network netstat_TcpExt_TCPDSACKUndo Congestion window recovered without slow start using DSACK count host,container proc fs network netstat_TcpExt_TCPDeferAcceptDrop - count host,container proc fs network netstat_TcpExt_TCPDelivered - count host,container proc fs network netstat_TcpExt_TCPDeliveredCE - count host,container proc fs network netstat_TcpExt_TCPFastOpenActive When the TCP stack receives an ACK packet in the SYN-SENT status, and the ACK packet acknowledges the data in the SYN packet, the TCP stack understand the TFO cookie is accepted by the other side, then it updates this counter count host,container proc fs network netstat_TcpExt_TCPFastOpenActiveFail Fast Open attempts (SYN/data) failed because the remote does not accept it or the attempts timed out count host,container proc fs network netstat_TcpExt_TCPFastOpenBlackhole - count host,container proc fs network netstat_TcpExt_TCPFastOpenCookieReqd This counter indicates how many times a client wants to request a TFO cookie count host,container proc fs network netstat_TcpExt_TCPFastOpenListenOverflow When the pending fast open request number is larger than fastopenq-&gt;max_qlen, the TCP stack will reject the fast open request and update this counter count host,container proc fs network netstat_TcpExt_TCPFastOpenPassive This counter indicates how many times the TCP stack accepts the fast open request count host,container proc fs network netstat_TcpExt_TCPFastOpenPassiveFail This counter indicates how many times the TCP stack rejects the fast open request. It is caused by either the TFO cookie is invalid or the TCP stack finds an error during the socket creating process count host,container proc fs network netstat_TcpExt_TCPFastRetrans The TCP stack wants to retransmit a packet and the congestion control state is not ‘Loss’ count host,container proc fs network netstat_TcpExt_TCPFromZeroWindowAdv The TCP receive window is set to no-zero value from zero count host,container proc fs network netstat_TcpExt_TCPFullUndo - count host,container proc fs network netstat_TcpExt_TCPHPAcks If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1 count host,container proc fs network netstat_TcpExt_TCPHPHits If a TCP packet has data (which means it is not a pure ACK packet), and this packet is handled in the fast path, TcpExtTCPHPHits will increase 1 count host,container proc fs network netstat_TcpExt_TCPHystartDelayCwnd The sum of CWND detected by packet delay. Dividing this value by TcpExtTCPHystartDelayDetect is the average CWND which detected by the packet delay count host,container proc fs network netstat_TcpExt_TCPHystartDelayDetect How many times the packet delay threshold is detected count host,container proc fs network netstat_TcpExt_TCPHystartTrainCwnd The sum of CWND detected by ACK train length. Dividing this value by TcpExtTCPHystartTrainDetect is the average CWND which detected by the ACK train length count host,container proc fs network netstat_TcpExt_TCPHystartTrainDetect How many times the ACK train length threshold is detected count host,container proc fs network netstat_TcpExt_TCPKeepAlive This counter indicates many keepalive packets were sent. The keepalive won’t be enabled by default. A userspace program could enable it by setting the SO_KEEPALIVE socket option count host,container proc fs network netstat_TcpExt_TCPLossFailures Number of connections that enter the TCP_CA_Loss phase and then undergo RTO timeout count host,container proc fs network netstat_TcpExt_TCPLossProbeRecovery A packet loss is detected and recovered by TLP count host,container proc fs network netstat_TcpExt_TCPLossProbes A TLP probe packet is sent count host,container proc fs network netstat_TcpExt_TCPLossUndo - count host,container proc fs network netstat_TcpExt_TCPLostRetransmit A SACK points out that a retransmission packet is lost again count host,container proc fs network netstat_TcpExt_TCPMD5Failure - count host,container proc fs network netstat_TcpExt_TCPMD5NotFound - count host,container proc fs network netstat_TcpExt_TCPMD5Unexpected - count host,container proc fs network netstat_TcpExt_TCPMTUPFail - count host,container proc fs network netstat_TcpExt_TCPMTUPSuccess - count host,container proc fs network netstat_TcpExt_TCPMemoryPressures Number of times TCP ran low on memory count host,container proc fs network netstat_TcpExt_TCPMemoryPressuresChrono - count host,container proc fs network netstat_TcpExt_TCPMinTTLDrop - count host,container proc fs network netstat_TcpExt_TCPOFODrop The TCP layer receives an out of order packet but doesn’t have enough memory, so drops it. Such packets won’t be counted into TcpExtTCPOFOQueue count host,container proc fs network netstat_TcpExt_TCPOFOMerge The received out of order packet has an overlay with the previous packet. the overlay part will be dropped. All of TcpExtTCPOFOMerge packets will also be counted into TcpExtTCPOFOQueue count host,container proc fs network netstat_TcpExt_TCPOFOQueue The TCP layer receives an out of order packet and has enough memory to queue it count host,container proc fs network netstat_TcpExt_TCPOrigDataSent Number of outgoing packets with original data (excluding retransmission but including data-in-SYN). This counter is different from TcpOutSegs because TcpOutSegs also tracks pure ACKs. TCPOrigDataSent is more useful to track the TCP retransmission rate count host,container proc fs network netstat_TcpExt_TCPPartialUndo Detected some erroneous retransmits, a partial ACK arrived while were fast retransmitting, so able to partially undo some of our CWND reduction count host,container proc fs network netstat_TcpExt_TCPPureAcks If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1, if kernel handles it in the slow path, TcpExtTCPPureAcks will increase 1 count host,container proc fs network netstat_TcpExt_TCPRcvCoalesce When packets are received by the TCP layer and are not be read by the application, the TCP layer will try to merge them. This counter indicate how many packets are merged in such situation. If GRO is enabled, lots of packets would be merged by GRO, these packets wouldn’t be counted to TcpExtTCPRcvCoalesce count host,container proc fs network netstat_TcpExt_TCPRcvCollapsed This counter indicates how many skbs are freed during ‘collapse’ count host,container proc fs network netstat_TcpExt_TCPRenoFailures Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPRenoRecovery When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets count host,container proc fs network netstat_TcpExt_TCPRenoRecoveryFail Number of connections that enter the Recovery phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPRenoReorder The reorder packet is detected by fast recovery. It would only be used if SACK is disabled count host,container proc fs network netstat_TcpExt_TCPReqQFullDoCookies - count host,container proc fs network netstat_TcpExt_TCPReqQFullDrop - count host,container proc fs network netstat_TcpExt_TCPRetransFail The TCP stack tries to deliver a retransmission packet to lower layers but the lower layers return an error count host,container proc fs network netstat_TcpExt_TCPSACKDiscard This counter indicates how many SACK blocks are invalid. If the invalid SACK block is caused by ACK recording, the TCP stack will only ignore it and won’t update this counter count host,container proc fs network netstat_TcpExt_TCPSACKReneging A packet was acknowledged by SACK, but the receiver has dropped this packet, so the sender needs to retransmit this packet count host,container proc fs network netstat_TcpExt_TCPSACKReorder The reorder packet detected by SACK count host,container proc fs network netstat_TcpExt_TCPSYNChallenge The number of challenge acks sent in response to SYN packets count host,container proc fs network netstat_TcpExt_TCPSackFailures Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPSackMerged A skb is merged count host,container proc fs network netstat_TcpExt_TCPSackRecovery When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets count host,container proc fs network netstat_TcpExt_TCPSackRecoveryFail When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1 count host,container proc fs network netstat_TcpExt_TCPSackShiftFallback A skb should be shifted or merged, but the TCP stack doesn’t do it for some reasons count host,container proc fs network netstat_TcpExt_TCPSackShifted A skb is shifted count host,container proc fs network netstat_TcpExt_TCPSlowStartRetrans The TCP stack wants to retransmit a packet and the congestion control state is ‘Loss’ count host,container proc fs network netstat_TcpExt_TCPSpuriousRTOs The spurious retransmission timeout detected by the F-RTO algorithm count host,container proc fs network netstat_TcpExt_TCPSpuriousRtxHostQueues When the TCP stack wants to retransmit a packet, and finds that packet is not lost in the network, but the packet is not sent yet, the TCP stack would give up the retransmission and update this counter. It might happen if a packet stays too long time in a qdisc or driver queue count host,container proc fs network netstat_TcpExt_TCPSynRetrans Number of SYN and SYN/ACK retransmits to break down retransmissions into SYN, fast-retransmits, timeout retransmits, etc count host,container proc fs network netstat_TcpExt_TCPTSReorder The reorder packet is detected when a hole is filled count host,container proc fs network netstat_TcpExt_TCPTimeWaitOverflow Number of TIME_WAIT sockets unable to be allocated due to limit exceeding count host,container proc fs network netstat_TcpExt_TCPTimeouts TCP timeout events count host,container proc fs network netstat_TcpExt_TCPToZeroWindowAdv The TCP receive window is set to zero from a no-zero value count host,container proc fs network netstat_TcpExt_TCPWantZeroWindowAdv Depending on current memory usage, the TCP stack tries to set receive window to zero. But the receive window might still be a no-zero value count host,container proc fs network netstat_TcpExt_TCPWinProbe Number of ACK packets to be sent at regular intervals to make sure a reverse ACK packet opening back a window has not been lost count host,container proc fs network netstat_TcpExt_TCPWqueueTooBig - count host,container proc fs network netstat_TcpExt_TW TCP sockets finished time wait in fast timer count host,container proc fs network netstat_TcpExt_TWKilled TCP sockets finished time wait in slow timer count host,container proc fs network netstat_TcpExt_TWRecycled Time wait sockets recycled by time stamp count host,container proc fs network netstat_Tcp_ActiveOpens It means the TCP layer sends a SYN, and come into the SYN-SENT state. Every time TcpActiveOpens increases 1, TcpOutSegs should always increase 1 count host,container proc fs network netstat_Tcp_AttemptFails The number of times TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state count host,container proc fs network netstat_Tcp_CurrEstab The number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT count host,container proc fs network netstat_Tcp_EstabResets The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state count host,container proc fs network netstat_Tcp_InCsumErrors Incremented when a TCP checksum failure is detected count host,container proc fs network netstat_Tcp_InErrs The total number of segments received in error (e.g., bad TCP checksums) count host,container proc fs network netstat_Tcp_InSegs The number of packets received by the TCP layer. As mentioned in RFC1213, it includes the packets received in error, such as checksum error, invalid TCP header and so on count host,container proc fs network netstat_Tcp_MaxConn The limit on the total number of TCP connections the entity can support. In entities where the maximum number of connections is dynamic, this object should contain the value -1 count host,container proc fs network netstat_Tcp_OutRsts The number of TCP segments sent containing the RST flag count host,container proc fs network netstat_Tcp_OutSegs The total number of segments sent, including those on current connections but excluding those containing only retransmitted octets count host,container proc fs network netstat_Tcp_PassiveOpens The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state count host,container proc fs network netstat_Tcp_RetransSegs The total number of segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets count host,container proc fs network netstat_Tcp_RtoAlgorithm The algorithm used to determine the timeout value used for retransmitting unacknowledged octets count host,container proc fs network netstat_Tcp_RtoMax The maximum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout count host,container proc fs network netstat_Tcp_RtoMin The minimum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout count host,container proc fs network sockstat_FRAG_inuse - count host,container proc fs network sockstat_FRAG_memory - pages host,container proc fs network sockstat_RAW_inuse Number of RAW socket used count host,container proc fs network sockstat_TCP_alloc The number of TCP sockets that have been allocated count host,container proc fs network sockstat_TCP_inuse Established TCP socket number count host,container proc fs network sockstat_TCP_mem The total size of TCP memory used by the system pages system proc fs network sockstat_TCP_mem_bytes The total size of TCP memory used by the system bytes system sockstat_TCP_mem * page_size network sockstat_TCP_orphan Number of TCP connections waiting to be closed count host,container proc fs network sockstat_TCP_tw Number of TCP sockets to be terminated count host,container proc fs network sockstat_UDPLITE_inuse - count host,container proc fs network sockstat_UDP_inuse Number of UDP socket used count host,container proc fs network sockstat_UDP_mem The total size of udp memory used by the system pages system proc fs network sockstat_UDP_mem_bytes The total number of bytes of udp memory used by the system bytes system sockstat_UDP_mem * page_size network sockstat_sockets_used The number of sockets used by the system count system proc fs">
  <meta itemprop="datePublished" content="2026-01-11T00:00:00+00:00">
  <meta itemprop="dateModified" content="2026-01-11T00:00:00+00:00">
  <meta itemprop="wordCount" content="5271">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Metrics">
  <meta name="twitter:description" content="Subsystem Metric Description Unit Dimension Source cpu cpu_util_sys Time of running kernel processes percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_usr Time of running user processes percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_total Total time of running percentage of host % host Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_sys Time of running kernel processes percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_usr Time of running user processes percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_util_container_total Total time of running percentage of container % container Calculate base on cpuacct.stat and cpuacct.usage cpu cpu_stat_container_burst_time Cumulative wall-time (in nanoseconds) that any CPUs has used above quota in respective periods ns container cpu.stat cpu cpu_stat_container_nr_bursts Number of periods burst occurs count container cpu.stat cpu cpu_stat_container_nr_throttled Number of times the group has been throttled/limited count container cpu.stat cpu cpu_stat_container_exter_wait_rate Wait rate caused by processes outside the container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_inner_wait_rate Wait rate caused by processes inside the container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_throttle_wait_rate Wait rate caused by throttle of container % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu cpu_stat_container_wait_rate Total wait rate: exter_wait_rate &#43; inner_wait_rate &#43; throttle_wait_rate % container Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat cpu loadavg_container_container_nr_running The number of running tasks in the container count container get from kernel via netlink cpu loadavg_container_container_nr_uninterruptible The number of uninterruptible tasks in the container count container get from kernel via netlink cpu loadavg_load1 System load avg over the last 1 minute count host proc fs cpu loadavg_load5 System load avg over the last 5 minute count host proc fs cpu loadavg_load15 system load avg over the last 15 minute count host proc fs cpu monsoftirq_latency The number of NET_RX/NET_TX irq latency happend in the following regions:
0~10 us
100us ~ 1ms
10us ~ 100us
1ms ~ inf count host hook the softirq event and do time statistics via bpf cpu runqlat_container_nlat_01 The number of times when schedule latency of processes in the container is within 0~10ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_02 The number of times when schedule latency of processes in the container is within 10~20ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_03 The number of times when schedule latency of processes in the container is within 20~50ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_container_nlat_04 The number of times when schedule latency of processes in the container is more than 50ms count container hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_01 The number of times when schedule latency of processes in the host is within
0~10ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_02 The number of times when schedule latency of processes in the host is within 10~20ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_03 The number of times when schedule latency of processes in the host is within 20~50ms count host hook the scheduling switch event and do time statistics via bpf cpu runqlat_g_nlat_04 The number of times when schedule latency of processes in the host is more than 50ms count host hook the scheduling switch event and do time statistics via bpf cpu reschedipi_oversell_probability The possibility of cpu overselling exists on the host where the vm is located 0-1 host hook the scheduling ipi event and do time statistics via bpf memory buddyinfo_blocks Kernel memory allocator information pages host proc fs memory memory_events_container_watermark_inc Counts of memory allocation watermark increasing count container memory.events memory memory_events_container_watermark_dec Counts of memory allocation watermark decreasing count container memory.events memory memory_others_container_local_direct_reclaim_time Time speed in page allocation in memory cgroup nanosecond container memory.local_direct_reclaim_time memory memory_others_container_directstall_time Memory cgroup’s direct reclaim time in try_charge nanosecond container memory.directstall_stat memory memory_others_container_asyncreclaim_time Memory cgroup’s direct reclaim time in cgroup async memory reclaim nanosecond container memory.asynreclaim_stat memory priority_reclaim_kswapd Kswapd’s reclaim stat in priority reclaiming pages host proc fs memory priority_reclaim_direct Direct reclaim stat in priority reclaiming pages host proc fs memory memory_stat_container_writeback Bytes of file/anon cache that are queued for syncing to disk bytes container memory.stat memory memory_stat_container_unevictable Bytes of memory that cannot be reclaimed (mlocked etc) bytes container memory.stat memory memory_stat_container_shmem Bytes of shmem memory bytes container memory.stat memory memory_stat_container_pgsteal_kswapd Bytes of reclaimed memory by kswapd and cswapd bytes container memory.stat memory memory_stat_container_pgsteal_globalkswapd Bytes of reclaimed memory by kswapd bytes container memory.stat memory memory_stat_container_pgsteal_globaldirect Bytes of reclaimed memory by direct reclaim during page allocation bytes container memory.stat memory memory_stat_container_pgsteal_direct Bytes of reclaimed memory by direct reclaim during page allocation and try_charge bytes container memory.stat memory memory_stat_container_pgsteal_cswapd Bytes of reclaimed memory by cswapd bytes container memory.stat memory memory_stat_container_pgscan_kswapd Bytes of scanned memory by kswapd and cswapd bytes container memory.stat memory memory_stat_container_pgscan_globalkswapd Bytes of scanned memory by kswapd bytes container memory.stat memory memory_stat_container_pgscan_globaldirect Bytes of scanned memory by direct reclaim during page allocation bytes container memory.stat memory memory_stat_container_pgscan_direct Bytes of scanned memory by direct reclaim during page allocation and try_charge bytes container memory.stat memory memory_stat_container_pgscan_cswapd Bytes of scanned memory by cswapd bytes container memory.stat memory memory_stat_container_pgrefill Bytes of memory that is scanned in active list bytes container memory.stat memory memory_stat_container_pgdeactivate Bytes of memory that is deactivated into inactive list bytes container memory.stat memory memory_stat_container_inactive_file Bytes of file-backed memory on inactive lru list. bytes container memory.stat memory memory_stat_container_inactive_anon Bytes of anonymous and swap cache memory on inactive lru list bytes container memory.stat memory memory_stat_container_dirty Bytes that are waiting to get written back to the disk bytes container memory.stat memory memory_stat_container_active_file Bytes of file-backed memory on active lru list bytes container memory.stat memory memory_stat_container_active_anon Bytes of anonymous and swap cache memory on active lru list bytes container memory.stat memory mountpoint_perm_ro Whether mountpoint is readonly or not bool host proc fs memory vmstat_allocstall_normal Host direct reclaim count on normal zone count host /proc/vmstat memory vmstat_allocstall_movable Host direct reclaim count on movable zone count host /proc/vmstat memory vmstat_compact_stall Count of memory compaction count host /proc/vmstat memory vmstat_nr_active_anon Number of anonymous pages on active lru pages host /proc/vmstat memory vmstat_nr_active_file Number of file-backed pages on active lru pages host /proc/vmstat memory vmstat_nr_boost_pages Number of pages in kswapd boosting pages host /proc/vmstat memory vmstat_nr_dirty Number of dirty pages pages host /proc/vmstat memory vmstat_nr_free_pages Number of free pages pages host /proc/vmstat memory vmstat_nr_inactive_anon Number of anonymous pages on inactive lru pages host /proc/vmstat memory vmstat_nr_inactive_file Number of file-backed pages on inactive lru pages host /proc/vmstat memory vmstat_nr_kswapd_boost Count of kswapd boosting pages host /proc/vmstat memory vmstat_nr_mlock Number of locked pages pages host /proc/vmstat memory vmstat_nr_shmem Number of shmem pages pages host /proc/vmstat memory vmstat_nr_slab_reclaimable Number of relcaimable slab pages pages host /proc/vmstat memory vmstat_nr_slab_unreclaimable Number of unrelcaimable slab pages pages host /proc/vmstat memory vmstat_nr_unevictable Number of unevictable pages pages host /proc/vmstat memory vmstat_nr_writeback Number of writebacking pages pages host /proc/vmstat memory vmstat_numa_pages_migrated Number of pages in numa migrating pages host /proc/vmstat memory vmstat_pgdeactivate Number of pages which are deactivated into inactive lru pages host /proc/vmstat memory vmstat_pgrefill Number of pages which are scanned on active lru pages host /proc/vmstat memory vmstat_pgscan_direct Number of pages which are scanned in direct reclaim pages host /proc/vmstat memory vmstat_pgscan_kswapd Number of pages which are scanned in kswapd reclaim pages host /proc/vmstat memory vmstat_pgsteal_direct Number of pages which are reclaimed in direct reclaim pages host /proc/vmstat memory vmstat_pgsteal_kswapd Number of pages which are reclaimed in kswapd reclaim pages host /proc/vmstat memory hungtask_happened Count of hungtask events count host performance and statistics monitoring for BPF Programs memory oom_happened Count of oom events count host,container performance and statistics monitoring for BPF Programs memory softlockup_happened Count of softlockup events count host performance and statistics monitoring for BPF Programs memory mmhostbpf_compactionstat Time speed in memory compaction nanosecond host performance and statistics monitoring for BPF Programs memory mmhostbpf_allocstallstat Time speed in memory direct reclaim on host nanosecond host performance and statistics monitoring for BPF Programs memory mmcgroupbpf_container_directstallcount Count of cgroup’s try_charge direct reclaim count container performance and statistics monitoring for BPF Programs IO iolatency_disk_d2c Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components count host performance and statistics monitoring for BPF Programs IO iolatency_disk_q2c Statistics of io latency for the entire io lifecycle when accessing the disk count host performance and statistics monitoring for BPF Programs IO iolatency_container_d2c Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components count container performance and statistics monitoring for BPF Programs IO iolatency_container_q2c Statistics of io latency for the entire io lifecycle when accessing the disk count container performance and statistics monitoring for BPF Programs IO iolatency_disk_flush Statistics of delay for flush operations on disk raid device count host performance and statistics monitoring for BPF Programs IO iolatency_container_flush Statistics of delay for flush operations on disk raid devices caused by containers count container performance and statistics monitoring for BPF Programs IO iolatency_disk_freeze Statistics of disk freeze events count host performance and statistics monitoring for BPF Programs network tcp_mem_limit_pages System TCP total memory size limit pages system proc fs network tcp_mem_usage_bytes The total number of bytes of TCP memory used by the system bytes system tcp_mem_usage_pages * page_size network tcp_mem_usage_pages The total size of TCP memory used by the system pages system proc fs network tcp_mem_usage_percent The percentage of TCP memory used by the system to the limit size % system tcp_mem_usage_pages / tcp_mem_limit_pages network arp_entries The number of arp cache entries count host,container proc fs network arp_total Total number of arp cache entries count system proc fs network qdisc_backlog The number of bytes queued to be sent bytes host sum of same level(parent major) for a device network qdisc_bytes_total The number of bytes sent bytes host sum of same level(parent major) for a device network qdisc_current_queue_length The number of packets queued for sending count host sum of same level(parent major) for a device network qdisc_drops_total The number of discarded packets count host sum of same level(parent major) for a device network qdisc_overlimits_total The number of queued packets exceeds the limit count host sum of same level(parent major) for a device network qdisc_packets_total The number of packets sent count host sum of same level(parent major) for a device network qdisc_requeues_total The number of packets that were not sent successfully and were requeued count host sum of same level(parent major) for a device network ethtool_hardware_rx_dropped_errors Statistics of inbound packet droped or errors of interface count host related to hardware drivers, such as mlx, ixgbe, bnxt_en, etc. network netdev_receive_bytes_total Number of good received bytes bytes host,container proc fs network netdev_receive_compressed_total Number of correctly received compressed packets count host,container proc fs network netdev_receive_dropped_total Number of packets received but not processed count host,container proc fs network netdev_receive_errors_total Total number of bad packets received on this network device count host,container proc fs network netdev_receive_fifo_total Receiver FIFO error counter count host,container proc fs network netdev_receive_frame_total Receiver frame alignment errors count host,container proc fs network netdev_receive_multicast_total Multicast packets received. For hardware interfaces this statistic is commonly calculated at the device level (unlike rx_packets) and therefore may include packets which did not reach the host count host,container proc fs network netdev_receive_packets_total Number of good packets received by the interface count host,container proc fs network netdev_transmit_bytes_total Number of good transmitted bytes, corresponding to tx_packets bytes host,container proc fs network netdev_transmit_carrier_total Number of frame transmission errors due to loss of carrier during transmission count host,container proc fs network netdev_transmit_colls_total Number of collisions during packet transmissions count host,container proc fs network netdev_transmit_compressed_total Number of transmitted compressed packets count host,container proc fs network netdev_transmit_dropped_total Number of packets dropped on their way to transmission, e.g. due to lack of resources count host,container proc fs network netdev_transmit_errors_total Total number of transmit problems count host,container proc fs network netdev_transmit_fifo_total Number of frame transmission errors due to device FIFO underrun / underflow count host,container proc fs network netdev_transmit_packets_total Number of packets successfully transmitted count host,container proc fs network netstat_TcpExt_ArpFilter - count host,container proc fs network netstat_TcpExt_BusyPollRxPackets - count host,container proc fs network netstat_TcpExt_DelayedACKLocked A delayed ACK timer expires, but the TCP stack can’t send an ACK immediately due to the socket is locked by a userspace program. The TCP stack will send a pure ACK later (after the userspace program unlock the socket). When the TCP stack sends the pure ACK later, the TCP stack will also update TcpExtDelayedACKs and exit the delayed ACK mode count host,container proc fs network netstat_TcpExt_DelayedACKLost It will be updated when the TCP stack receives a packet which has been ACKed. A Delayed ACK loss might cause this issue, but it would also be triggered by other reasons, such as a packet is duplicated in the network count host,container proc fs network netstat_TcpExt_DelayedACKs A delayed ACK timer expires. The TCP stack will send a pure ACK packet and exit the delayed ACK mode count host,container proc fs network netstat_TcpExt_EmbryonicRsts resets received for embryonic SYN_RECV sockets count host,container proc fs network netstat_TcpExt_IPReversePathFilter - count host,container proc fs network netstat_TcpExt_ListenDrops When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase count host,container proc fs network netstat_TcpExt_ListenOverflows When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase count host,container proc fs network netstat_TcpExt_LockDroppedIcmps ICMP packets dropped because socket was locked count host,container proc fs network netstat_TcpExt_OfoPruned The TCP stack tries to discard packet on the out of order queue count host,container proc fs network netstat_TcpExt_OutOfWindowIcmps ICMP pkts dropped because they were out-of-window count host,container proc fs network netstat_TcpExt_PAWSActive Packets are dropped by PAWS in Syn-Sent status count host,container proc fs network netstat_TcpExt_PAWSEstab Packets are dropped by PAWS in any status other than Syn-Sent count host,container proc fs network netstat_TcpExt_PFMemallocDrop - count host,container proc fs network netstat_TcpExt_PruneCalled The TCP stack tries to reclaim memory for a socket. After updates this counter, the TCP stack will try to collapse the out of order queue and the receiving queue. If the memory is still not enough, the TCP stack will try to discard packets from the out of order queue (and update the TcpExtOfoPruned counter) count host,container proc fs network netstat_TcpExt_RcvPruned After ‘collapse’ and discard packets from the out of order queue, if the actually used memory is still larger than the max allowed memory, this counter will be updated. It means the ‘prune’ fails count host,container proc fs network netstat_TcpExt_SyncookiesFailed The MSS decoded from the SYN cookie is invalid. When this counter is updated, the received packet won’t be treated as a SYN cookie and the TcpExtSyncookiesRecv counter won’t be updated count host,container proc fs network netstat_TcpExt_SyncookiesRecv How many reply packets of the SYN cookies the TCP stack receives count host,container proc fs network netstat_TcpExt_SyncookiesSent It indicates how many SYN cookies are sent count host,container proc fs network netstat_TcpExt_TCPACKSkippedChallenge The ACK is skipped if the ACK is a challenge ACK count host,container proc fs network netstat_TcpExt_TCPACKSkippedFinWait2 The ACK is skipped in Fin-Wait-2 status, the reason would be either PAWS check fails or the received sequence number is out of window count host,container proc fs network netstat_TcpExt_TCPACKSkippedPAWS The ACK is skipped due to PAWS (Protect Against Wrapped Sequence numbers) check fails count host,container proc fs network netstat_TcpExt_TCPACKSkippedSeq The sequence number is out of window and the timestamp passes the PAWS check and the TCP status is not Syn-Recv, Fin-Wait-2, and Time-Wait count host,container proc fs network netstat_TcpExt_TCPACKSkippedSynRecv The ACK is skipped in Syn-Recv status. The Syn-Recv status means the TCP stack receives a SYN and replies SYN&#43;ACK count host,container proc fs network netstat_TcpExt_TCPACKSkippedTimeWait The ACK is skipped in Time-Wait status, the reason would be either PAWS check failed or the received sequence number is out of window count host,container proc fs network netstat_TcpExt_TCPAbortFailed The kernel TCP layer will send RST if the RFC2525 2.17 section is satisfied. If an internal error occurs during this process, TcpExtTCPAbortFailed will be increased count host,container proc fs network netstat_TcpExt_TCPAbortOnClose Number of sockets closed when the user-mode program has data in the buffer count host,container proc fs network netstat_TcpExt_TCPAbortOnData It means TCP layer has data in flight, but need to close the connection count host,container proc fs network netstat_TcpExt_TCPAbortOnLinger When a TCP connection comes into FIN_WAIT_2 state, instead of waiting for the fin packet from the other side, kernel could send a RST and delete the socket immediately count host,container proc fs network netstat_TcpExt_TCPAbortOnMemory When an application closes a TCP connection, kernel still need to track the connection, let it complete the TCP disconnect process count host,container proc fs network netstat_TcpExt_TCPAbortOnTimeout This counter will increase when any of the TCP timers expire. In such situation, kernel won’t send RST, just give up the connection count host,container proc fs network netstat_TcpExt_TCPAckCompressed - count host,container proc fs network netstat_TcpExt_TCPAutoCorking When sending packets, the TCP layer will try to merge small packets to a bigger one count host,container proc fs network netstat_TcpExt_TCPBacklogDrop - count host,container proc fs network netstat_TcpExt_TCPChallengeACK The number of challenge acks sent count host,container proc fs network netstat_TcpExt_TCPDSACKIgnoredNoUndo When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket count host,container proc fs network netstat_TcpExt_TCPDSACKIgnoredOld When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket count host,container proc fs network netstat_TcpExt_TCPDSACKOfoRecv The TCP stack receives a DSACK, which indicate an out of order duplicate packet is received count host,container proc fs network netstat_TcpExt_TCPDSACKOfoSent The TCP stack receives an out of order duplicate packet, so it sends a DSACK to the sender count host,container proc fs network netstat_TcpExt_TCPDSACKOldSent The TCP stack receives a duplicate packet which has been acked, so it sends a DSACK to the sender count host,container proc fs network netstat_TcpExt_TCPDSACKRecv The TCP stack receives a DSACK, which indicates an acknowledged duplicate packet is received count host,container proc fs network netstat_TcpExt_TCPDSACKUndo Congestion window recovered without slow start using DSACK count host,container proc fs network netstat_TcpExt_TCPDeferAcceptDrop - count host,container proc fs network netstat_TcpExt_TCPDelivered - count host,container proc fs network netstat_TcpExt_TCPDeliveredCE - count host,container proc fs network netstat_TcpExt_TCPFastOpenActive When the TCP stack receives an ACK packet in the SYN-SENT status, and the ACK packet acknowledges the data in the SYN packet, the TCP stack understand the TFO cookie is accepted by the other side, then it updates this counter count host,container proc fs network netstat_TcpExt_TCPFastOpenActiveFail Fast Open attempts (SYN/data) failed because the remote does not accept it or the attempts timed out count host,container proc fs network netstat_TcpExt_TCPFastOpenBlackhole - count host,container proc fs network netstat_TcpExt_TCPFastOpenCookieReqd This counter indicates how many times a client wants to request a TFO cookie count host,container proc fs network netstat_TcpExt_TCPFastOpenListenOverflow When the pending fast open request number is larger than fastopenq-&gt;max_qlen, the TCP stack will reject the fast open request and update this counter count host,container proc fs network netstat_TcpExt_TCPFastOpenPassive This counter indicates how many times the TCP stack accepts the fast open request count host,container proc fs network netstat_TcpExt_TCPFastOpenPassiveFail This counter indicates how many times the TCP stack rejects the fast open request. It is caused by either the TFO cookie is invalid or the TCP stack finds an error during the socket creating process count host,container proc fs network netstat_TcpExt_TCPFastRetrans The TCP stack wants to retransmit a packet and the congestion control state is not ‘Loss’ count host,container proc fs network netstat_TcpExt_TCPFromZeroWindowAdv The TCP receive window is set to no-zero value from zero count host,container proc fs network netstat_TcpExt_TCPFullUndo - count host,container proc fs network netstat_TcpExt_TCPHPAcks If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1 count host,container proc fs network netstat_TcpExt_TCPHPHits If a TCP packet has data (which means it is not a pure ACK packet), and this packet is handled in the fast path, TcpExtTCPHPHits will increase 1 count host,container proc fs network netstat_TcpExt_TCPHystartDelayCwnd The sum of CWND detected by packet delay. Dividing this value by TcpExtTCPHystartDelayDetect is the average CWND which detected by the packet delay count host,container proc fs network netstat_TcpExt_TCPHystartDelayDetect How many times the packet delay threshold is detected count host,container proc fs network netstat_TcpExt_TCPHystartTrainCwnd The sum of CWND detected by ACK train length. Dividing this value by TcpExtTCPHystartTrainDetect is the average CWND which detected by the ACK train length count host,container proc fs network netstat_TcpExt_TCPHystartTrainDetect How many times the ACK train length threshold is detected count host,container proc fs network netstat_TcpExt_TCPKeepAlive This counter indicates many keepalive packets were sent. The keepalive won’t be enabled by default. A userspace program could enable it by setting the SO_KEEPALIVE socket option count host,container proc fs network netstat_TcpExt_TCPLossFailures Number of connections that enter the TCP_CA_Loss phase and then undergo RTO timeout count host,container proc fs network netstat_TcpExt_TCPLossProbeRecovery A packet loss is detected and recovered by TLP count host,container proc fs network netstat_TcpExt_TCPLossProbes A TLP probe packet is sent count host,container proc fs network netstat_TcpExt_TCPLossUndo - count host,container proc fs network netstat_TcpExt_TCPLostRetransmit A SACK points out that a retransmission packet is lost again count host,container proc fs network netstat_TcpExt_TCPMD5Failure - count host,container proc fs network netstat_TcpExt_TCPMD5NotFound - count host,container proc fs network netstat_TcpExt_TCPMD5Unexpected - count host,container proc fs network netstat_TcpExt_TCPMTUPFail - count host,container proc fs network netstat_TcpExt_TCPMTUPSuccess - count host,container proc fs network netstat_TcpExt_TCPMemoryPressures Number of times TCP ran low on memory count host,container proc fs network netstat_TcpExt_TCPMemoryPressuresChrono - count host,container proc fs network netstat_TcpExt_TCPMinTTLDrop - count host,container proc fs network netstat_TcpExt_TCPOFODrop The TCP layer receives an out of order packet but doesn’t have enough memory, so drops it. Such packets won’t be counted into TcpExtTCPOFOQueue count host,container proc fs network netstat_TcpExt_TCPOFOMerge The received out of order packet has an overlay with the previous packet. the overlay part will be dropped. All of TcpExtTCPOFOMerge packets will also be counted into TcpExtTCPOFOQueue count host,container proc fs network netstat_TcpExt_TCPOFOQueue The TCP layer receives an out of order packet and has enough memory to queue it count host,container proc fs network netstat_TcpExt_TCPOrigDataSent Number of outgoing packets with original data (excluding retransmission but including data-in-SYN). This counter is different from TcpOutSegs because TcpOutSegs also tracks pure ACKs. TCPOrigDataSent is more useful to track the TCP retransmission rate count host,container proc fs network netstat_TcpExt_TCPPartialUndo Detected some erroneous retransmits, a partial ACK arrived while were fast retransmitting, so able to partially undo some of our CWND reduction count host,container proc fs network netstat_TcpExt_TCPPureAcks If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1, if kernel handles it in the slow path, TcpExtTCPPureAcks will increase 1 count host,container proc fs network netstat_TcpExt_TCPRcvCoalesce When packets are received by the TCP layer and are not be read by the application, the TCP layer will try to merge them. This counter indicate how many packets are merged in such situation. If GRO is enabled, lots of packets would be merged by GRO, these packets wouldn’t be counted to TcpExtTCPRcvCoalesce count host,container proc fs network netstat_TcpExt_TCPRcvCollapsed This counter indicates how many skbs are freed during ‘collapse’ count host,container proc fs network netstat_TcpExt_TCPRenoFailures Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPRenoRecovery When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets count host,container proc fs network netstat_TcpExt_TCPRenoRecoveryFail Number of connections that enter the Recovery phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPRenoReorder The reorder packet is detected by fast recovery. It would only be used if SACK is disabled count host,container proc fs network netstat_TcpExt_TCPReqQFullDoCookies - count host,container proc fs network netstat_TcpExt_TCPReqQFullDrop - count host,container proc fs network netstat_TcpExt_TCPRetransFail The TCP stack tries to deliver a retransmission packet to lower layers but the lower layers return an error count host,container proc fs network netstat_TcpExt_TCPSACKDiscard This counter indicates how many SACK blocks are invalid. If the invalid SACK block is caused by ACK recording, the TCP stack will only ignore it and won’t update this counter count host,container proc fs network netstat_TcpExt_TCPSACKReneging A packet was acknowledged by SACK, but the receiver has dropped this packet, so the sender needs to retransmit this packet count host,container proc fs network netstat_TcpExt_TCPSACKReorder The reorder packet detected by SACK count host,container proc fs network netstat_TcpExt_TCPSYNChallenge The number of challenge acks sent in response to SYN packets count host,container proc fs network netstat_TcpExt_TCPSackFailures Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO count host,container proc fs network netstat_TcpExt_TCPSackMerged A skb is merged count host,container proc fs network netstat_TcpExt_TCPSackRecovery When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets count host,container proc fs network netstat_TcpExt_TCPSackRecoveryFail When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1 count host,container proc fs network netstat_TcpExt_TCPSackShiftFallback A skb should be shifted or merged, but the TCP stack doesn’t do it for some reasons count host,container proc fs network netstat_TcpExt_TCPSackShifted A skb is shifted count host,container proc fs network netstat_TcpExt_TCPSlowStartRetrans The TCP stack wants to retransmit a packet and the congestion control state is ‘Loss’ count host,container proc fs network netstat_TcpExt_TCPSpuriousRTOs The spurious retransmission timeout detected by the F-RTO algorithm count host,container proc fs network netstat_TcpExt_TCPSpuriousRtxHostQueues When the TCP stack wants to retransmit a packet, and finds that packet is not lost in the network, but the packet is not sent yet, the TCP stack would give up the retransmission and update this counter. It might happen if a packet stays too long time in a qdisc or driver queue count host,container proc fs network netstat_TcpExt_TCPSynRetrans Number of SYN and SYN/ACK retransmits to break down retransmissions into SYN, fast-retransmits, timeout retransmits, etc count host,container proc fs network netstat_TcpExt_TCPTSReorder The reorder packet is detected when a hole is filled count host,container proc fs network netstat_TcpExt_TCPTimeWaitOverflow Number of TIME_WAIT sockets unable to be allocated due to limit exceeding count host,container proc fs network netstat_TcpExt_TCPTimeouts TCP timeout events count host,container proc fs network netstat_TcpExt_TCPToZeroWindowAdv The TCP receive window is set to zero from a no-zero value count host,container proc fs network netstat_TcpExt_TCPWantZeroWindowAdv Depending on current memory usage, the TCP stack tries to set receive window to zero. But the receive window might still be a no-zero value count host,container proc fs network netstat_TcpExt_TCPWinProbe Number of ACK packets to be sent at regular intervals to make sure a reverse ACK packet opening back a window has not been lost count host,container proc fs network netstat_TcpExt_TCPWqueueTooBig - count host,container proc fs network netstat_TcpExt_TW TCP sockets finished time wait in fast timer count host,container proc fs network netstat_TcpExt_TWKilled TCP sockets finished time wait in slow timer count host,container proc fs network netstat_TcpExt_TWRecycled Time wait sockets recycled by time stamp count host,container proc fs network netstat_Tcp_ActiveOpens It means the TCP layer sends a SYN, and come into the SYN-SENT state. Every time TcpActiveOpens increases 1, TcpOutSegs should always increase 1 count host,container proc fs network netstat_Tcp_AttemptFails The number of times TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state count host,container proc fs network netstat_Tcp_CurrEstab The number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT count host,container proc fs network netstat_Tcp_EstabResets The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state count host,container proc fs network netstat_Tcp_InCsumErrors Incremented when a TCP checksum failure is detected count host,container proc fs network netstat_Tcp_InErrs The total number of segments received in error (e.g., bad TCP checksums) count host,container proc fs network netstat_Tcp_InSegs The number of packets received by the TCP layer. As mentioned in RFC1213, it includes the packets received in error, such as checksum error, invalid TCP header and so on count host,container proc fs network netstat_Tcp_MaxConn The limit on the total number of TCP connections the entity can support. In entities where the maximum number of connections is dynamic, this object should contain the value -1 count host,container proc fs network netstat_Tcp_OutRsts The number of TCP segments sent containing the RST flag count host,container proc fs network netstat_Tcp_OutSegs The total number of segments sent, including those on current connections but excluding those containing only retransmitted octets count host,container proc fs network netstat_Tcp_PassiveOpens The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state count host,container proc fs network netstat_Tcp_RetransSegs The total number of segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets count host,container proc fs network netstat_Tcp_RtoAlgorithm The algorithm used to determine the timeout value used for retransmitting unacknowledged octets count host,container proc fs network netstat_Tcp_RtoMax The maximum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout count host,container proc fs network netstat_Tcp_RtoMin The minimum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout count host,container proc fs network sockstat_FRAG_inuse - count host,container proc fs network sockstat_FRAG_memory - pages host,container proc fs network sockstat_RAW_inuse Number of RAW socket used count host,container proc fs network sockstat_TCP_alloc The number of TCP sockets that have been allocated count host,container proc fs network sockstat_TCP_inuse Established TCP socket number count host,container proc fs network sockstat_TCP_mem The total size of TCP memory used by the system pages system proc fs network sockstat_TCP_mem_bytes The total size of TCP memory used by the system bytes system sockstat_TCP_mem * page_size network sockstat_TCP_orphan Number of TCP connections waiting to be closed count host,container proc fs network sockstat_TCP_tw Number of TCP sockets to be terminated count host,container proc fs network sockstat_UDPLITE_inuse - count host,container proc fs network sockstat_UDP_inuse Number of UDP socket used count host,container proc fs network sockstat_UDP_mem The total size of udp memory used by the system pages system proc fs network sockstat_UDP_mem_bytes The total number of bytes of udp memory used by the system bytes system sockstat_UDP_mem * page_size network sockstat_sockets_used The number of sockets used by the system count system proc fs">
<link rel="preload" href="/docs/scss/main.min.c95504f27a87559d8da98b30ce0afae5c15400b756d8cb3fa59672f87bf67399.css" as="style" integrity="sha256-yVUE8nqHVZ2NqYswzgr65cFUALdW2Ms/pZZy&#43;Hv2c5k=" crossorigin="anonymous">
<link href="/docs/scss/main.min.c95504f27a87559d8da98b30ce0afae5c15400b756d8cb3fa59672f87bf67399.css" rel="stylesheet" integrity="sha256-yVUE8nqHVZ2NqYswzgr65cFUALdW2Ms/pZZy&#43;Hv2c5k=" crossorigin="anonymous">
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
  crossorigin="anonymous"></script>
<script defer
  src="https://unpkg.com/lunr@2.3.9/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>

  </head>
  <body class="td-page">
    <header>
      <nav class="td-navbar js-navbar-scroll" data-bs-theme="dark">
<div class="td-navbar-container container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/docs/en/"><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class="navbar-brand__name">HUATUO Doc</span></a>
  <div class="td-navbar-nav-scroll td-navbar-nav-scroll--indicator" id="main_navbar">
    <div class="scroll-indicator scroll-left"></div>
    <ul class="navbar-nav">
      <li class="nav-item dropdown d-none d-lg-block td-navbar__version-menu">
        
                   


                


                 




        





  

  

  

  

                               
    
  

                               
    
  

                               
    
  




    


<div class="dropdown">
  <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    
      latest
    
  </a>

  <ul class="dropdown-menu">
    

    
      

      
        
        
      

      <li>
        <a class="dropdown-item active" 
           href="/docs/docs/latest/"
           aria-current="true">
          latest
        </a>
      </li>
    
      

      
        
        
      

      <li>
        <a class="dropdown-item " 
           href="/docs/docs/v2.1.0/"
           >
          v2.1.0
        </a>
      </li>
    
      

      
        
        
      

      <li>
        <a class="dropdown-item " 
           href="/docs/docs/v2.0.0/"
           >
          v2.0.0
        </a>
      </li>
    
  </ul>
</div>
</li>
      <li class="nav-item td-navbar__lang-menu">
        <div class="td-lang-menu dropdown">
  <a class="nav-link dropdown-toggle td-lang-menu__title" href="#" role="button"
    data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    <span class="td-lang-menu__title-text">English</span>
    <span class="td-lang-menu__title-code">EN</span>
  </a>
  <ul class="dropdown-menu">
    <li><span class="dropdown-item active">English</span></li>
      <li><a class="dropdown-item" href="/docs/zh/latest/key-feature/metrics/">中文</a></li>
      </ul>
</div></li>
      <li class="nav-item td-navbar__light-dark-menu">
        <div class="td-light-dark-menu dropdown"><svg xmlns="http://www.w3.org/2000/svg" class="d-none">
  <symbol id="check2" viewBox="0 0 16 16">
    <path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"/>
  </symbol>
  <symbol id="circle-half" viewBox="0 0 16 16">
    <path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"/>
  </symbol>
  <symbol id="moon-stars-fill" viewBox="0 0 16 16">
    <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
    <path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"/>
  </symbol>
  <symbol id="sun-fill" viewBox="0 0 16 16">
    <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
  </symbol>
</svg>
<button class="btn btn-link nav-link dropdown-toggle d-flex align-items-center"
        id="bd-theme"
        type="button"
        aria-expanded="false"
        data-bs-toggle="dropdown"
        aria-label="Toggle theme (auto)">
  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg>
</button>
<ul class="dropdown-menu" aria-labelledby="bd-theme">
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
      <svg class="bi me-2 opacity-50"><use href="#sun-fill"></use></svg>
      Light
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
      <svg class="bi me-2 opacity-50"><use href="#moon-stars-fill"></use></svg>
      Dark
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
  <li>
    <button type="button" class="dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
      <svg class="bi me-2 opacity-50"><use href="#circle-half"></use></svg>
      Auto
      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg>
    </button>
  </li>
</ul>
</div>

      </li>
      </ul>
    <div class="scroll-indicator scroll-right"></div>
  </div>
  <div class="d-none d-lg-block td-navbar__search">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="Search this site…"
    aria-label="Search this site…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/docs/offline-search-index.1c9bafb5818622ef1251641a80b3bcd7.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main" data-bs-spy="scroll" data-bs-target=".td-toc" data-bs-root-margin="0px 0px -10%">
        <div class="row flex-xl-nowrap">
          <aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
            <div id="td-sidebar-menu" class="td-sidebar__inner">
  <form class="td-sidebar__search d-flex align-items-center">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="Search this site…"
    aria-label="Search this site…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/docs/offline-search-index.1c9bafb5818622ef1251641a80b3bcd7.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
    <button class="btn btn-link td-sidebar__toggle" type="button" data-bs-toggle="collapse" data-bs-target="#td-section-nav" aria-controls="td-section-nav" aria-expanded="false" aria-label="Toggle section navigation">
    </button>
  </form>
  <nav class="td-sidebar-nav collapse foldable-nav" id="td-section-nav">
    <ul class="td-sidebar-nav__section pe-md-3 ul-0">
      
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id="m-docsenlatest-li">
    <a href="/docs/en/latest/" class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id="m-docsenlatest"><span class="">latest</span></a>
    <ul class="ul-1">
      
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestquick-start-li">
    <input type="checkbox" id="m-docsenlatestquick-start-check"/>
    <label for="m-docsenlatestquick-start-check"><a href="/docs/en/latest/quick-start/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestquick-start"><span class="">Getting started</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id="m-docsenlatestdeployment-li">
    <input type="checkbox" id="m-docsenlatestdeployment-check"/>
    <label for="m-docsenlatestdeployment-check"><a href="/docs/en/latest/deployment/" class="align-left ps-0  td-sidebar-link td-sidebar-link__section" id="m-docsenlatestdeployment"><span class="">Deploy</span></a></label>
    
    <ul class="ul-2 foldable">
      
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestdeploymentdocker-li">
    <input type="checkbox" id="m-docsenlatestdeploymentdocker-check"/>
    <label for="m-docsenlatestdeploymentdocker-check"><a href="/docs/en/latest/deployment/docker/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestdeploymentdocker"><span class="">Docker</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestdeploymentdaemonset-li">
    <input type="checkbox" id="m-docsenlatestdeploymentdaemonset-check"/>
    <label for="m-docsenlatestdeploymentdaemonset-check"><a href="/docs/en/latest/deployment/daemonset/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestdeploymentdaemonset"><span class="">Daemonset</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestdeploymentsystemd-li">
    <input type="checkbox" id="m-docsenlatestdeploymentsystemd-check"/>
    <label for="m-docsenlatestdeploymentsystemd-check"><a href="/docs/en/latest/deployment/systemd/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestdeploymentsystemd"><span class="">Systemd</span></a></label>
    
  </li>
    </ul>
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestcompiling-li">
    <input type="checkbox" id="m-docsenlatestcompiling-check"/>
    <label for="m-docsenlatestcompiling-check"><a href="/docs/en/latest/compiling/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestcompiling"><span class="">Compile</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id="m-docsenlatestkey-feature-li">
    <input type="checkbox" id="m-docsenlatestkey-feature-check" checked/>
    <label for="m-docsenlatestkey-feature-check"><a href="/docs/en/latest/key-feature/" class="align-left ps-0  td-sidebar-link td-sidebar-link__section" id="m-docsenlatestkey-feature"><span class="">Key Feature</span></a></label>
    
    <ul class="ul-2 foldable">
      
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id="m-docsenlatestkey-featuremetrics-li">
    <input type="checkbox" id="m-docsenlatestkey-featuremetrics-check" checked/>
    <label for="m-docsenlatestkey-featuremetrics-check"><a href="/docs/en/latest/key-feature/metrics/" class="align-left ps-0  active td-sidebar-link td-sidebar-link__page" id="m-docsenlatestkey-featuremetrics"><span class="td-sidebar-nav-active-item">Metrics</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestkey-featureevents-li">
    <input type="checkbox" id="m-docsenlatestkey-featureevents-check"/>
    <label for="m-docsenlatestkey-featureevents-check"><a href="/docs/en/latest/key-feature/events/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestkey-featureevents"><span class="">Events</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestkey-featureautotracing-li">
    <input type="checkbox" id="m-docsenlatestkey-featureautotracing-check"/>
    <label for="m-docsenlatestkey-featureautotracing-check"><a href="/docs/en/latest/key-feature/autotracing/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestkey-featureautotracing"><span class="">Autotracing</span></a></label>
    
  </li>
    </ul>
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestbest-practice-li">
    <input type="checkbox" id="m-docsenlatestbest-practice-check"/>
    <label for="m-docsenlatestbest-practice-check"><a href="/docs/en/latest/best-practice/" class="align-left ps-0  td-sidebar-link td-sidebar-link__section" id="m-docsenlatestbest-practice"><span class="">Best Practice</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id="m-docsenlatestdevelopment-li">
    <input type="checkbox" id="m-docsenlatestdevelopment-check"/>
    <label for="m-docsenlatestdevelopment-check"><a href="/docs/en/latest/development/" class="align-left ps-0  td-sidebar-link td-sidebar-link__section" id="m-docsenlatestdevelopment"><span class="">Development</span></a></label>
    
    <ul class="ul-2 foldable">
      
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestdevelopmentmode-li">
    <input type="checkbox" id="m-docsenlatestdevelopmentmode-check"/>
    <label for="m-docsenlatestdevelopmentmode-check"><a href="/docs/en/latest/development/mode/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestdevelopmentmode"><span class="">Collection Framework</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestdevelopmentmetrics-li">
    <input type="checkbox" id="m-docsenlatestdevelopmentmetrics-check"/>
    <label for="m-docsenlatestdevelopmentmetrics-check"><a href="/docs/en/latest/development/metrics/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestdevelopmentmetrics"><span class="">Add Metrics</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestdevelopmentevents-li">
    <input type="checkbox" id="m-docsenlatestdevelopmentevents-check"/>
    <label for="m-docsenlatestdevelopmentevents-check"><a href="/docs/en/latest/development/events/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestdevelopmentevents"><span class="">Add Event</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestdevelopmentautotracing-li">
    <input type="checkbox" id="m-docsenlatestdevelopmentautotracing-check"/>
    <label for="m-docsenlatestdevelopmentautotracing-check"><a href="/docs/en/latest/development/autotracing/" class="align-left ps-0  td-sidebar-link td-sidebar-link__page" id="m-docsenlatestdevelopmentautotracing"><span class="">Add Autotracing</span></a></label>
    
  </li>
    </ul>
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestfaq-li">
    <input type="checkbox" id="m-docsenlatestfaq-check"/>
    <label for="m-docsenlatestfaq-check"><a href="/docs/en/latest/faq/" class="align-left ps-0  td-sidebar-link td-sidebar-link__section" id="m-docsenlatestfaq"><span class="">Frequenty Asked Questions</span></a></label>
    
  </li>
  
  
  
    
  
  
    
  
  <li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id="m-docsenlatestcontribute-li">
    <input type="checkbox" id="m-docsenlatestcontribute-check"/>
    <label for="m-docsenlatestcontribute-check"><a href="/docs/en/latest/contribute/" class="align-left ps-0  td-sidebar-link td-sidebar-link__section" id="m-docsenlatestcontribute"><span class="">Contribute</span></a></label>
    
  </li>
    </ul>
  </li>
    </ul>
  </nav>
</div>
          </aside>
          <aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none">
            <div class="td-page-meta ms-2 pb-1 pt-2 mb-0">
<a href="https://github.com/fanzu8/huatuo-docs/tree/main/content/en/latest/key-feature/metrics.md" class="td-page-meta--view td-page-meta__view" target="_blank" rel="noopener"><i class="fa-solid fa-file-lines fa-fw"></i> View page source</a>
  <a href="https://github.com/fanzu8/huatuo-docs/edit/main/content/en/latest/key-feature/metrics.md" class="td-page-meta--edit td-page-meta__edit" target="_blank" rel="noopener"><i class="fa-solid fa-pen-to-square fa-fw"></i> Edit this page</a>
  <a href="https://github.com/fanzu8/huatuo-docs/new/main/content/en/latest/key-feature?filename=change-me.md&amp;value=---%0Atitle%3A&#43;%22Long&#43;Page&#43;Title%22%0AlinkTitle%3A&#43;%22Short&#43;Nav&#43;Title%22%0Aweight%3A&#43;100%0Adescription%3A&#43;%3E-%0A&#43;&#43;&#43;&#43;&#43;Page&#43;description&#43;for&#43;heading&#43;and&#43;indexes.%0A---%0A%0A%23%23&#43;Heading%0A%0AEdit&#43;this&#43;template&#43;to&#43;create&#43;your&#43;new&#43;page.%0A%0A%2A&#43;Give&#43;it&#43;a&#43;good&#43;name%2C&#43;ending&#43;in&#43;%60.md%60&#43;-&#43;e.g.&#43;%60getting-started.md%60%0A%2A&#43;Edit&#43;the&#43;%22front&#43;matter%22&#43;section&#43;at&#43;the&#43;top&#43;of&#43;the&#43;page&#43;%28weight&#43;controls&#43;how&#43;its&#43;ordered&#43;amongst&#43;other&#43;pages&#43;in&#43;the&#43;same&#43;directory%3B&#43;lowest&#43;number&#43;first%29.%0A%2A&#43;Add&#43;a&#43;good&#43;commit&#43;message&#43;at&#43;the&#43;bottom&#43;of&#43;the&#43;page&#43;%28%3C80&#43;characters%3B&#43;use&#43;the&#43;extended&#43;description&#43;field&#43;for&#43;more&#43;detail%29.%0A%2A&#43;Create&#43;a&#43;new&#43;branch&#43;so&#43;you&#43;can&#43;preview&#43;your&#43;new&#43;file&#43;and&#43;request&#43;a&#43;review&#43;via&#43;Pull&#43;Request.%0A" class="td-page-meta--child td-page-meta__child" target="_blank" rel="noopener"><i class="fa-solid fa-pen-to-square fa-fw"></i> Create child page</a>
  <a href="https://github.com/fanzu8/huatuo-docs/issues/new?title=Metrics" class="td-page-meta--issue td-page-meta__issue" target="_blank" rel="noopener"><i class="fa-solid fa-list-check fa-fw"></i> Create documentation issue</a>
  <a href="https://github.com/ccfos/huatuo/issues/new" class="td-page-meta--project td-page-meta__project-issue" target="_blank" rel="noopener"><i class="fa-solid fa-list-check fa-fw"></i> Create project issue</a>
  <a id="print" href="/docs/en/latest/key-feature/_print/"><i class="fa-solid fa-print fa-fw"></i> Print entire section</a>

</div>

            <div class="td-toc" data-proofer-ignore>
</div>

            
	
          </aside>
          <main class="col-12 col-md-9 col-xl-8 ps-md-5" role="main">
            
  

            <nav aria-label="breadcrumb" class="td-breadcrumbs">
  <ol class="breadcrumb">
  <li class="breadcrumb-item">
    <a href="/docs/en/latest/">latest</a></li>
  <li class="breadcrumb-item">
    <a href="/docs/en/latest/key-feature/">Key Feature</a></li>
  <li class="breadcrumb-item active" aria-current="page">
    Metrics</li>
  </ol>
</nav>
<div class="td-content">
	<h1>Metrics</h1>
	
	<header class="article-meta">
		
  </header>
	<table>
  <thead>
      <tr>
          <th>Subsystem</th>
          <th>Metric</th>
          <th>Description</th>
          <th>Unit</th>
          <th>Dimension</th>
          <th>Source</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>cpu</td>
          <td>cpu_util_sys</td>
          <td>Time of running kernel processes percentage of host</td>
          <td>%</td>
          <td>host</td>
          <td>Calculate base on cpuacct.stat and cpuacct.usage</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_util_usr</td>
          <td>Time of running user processes percentage of host</td>
          <td>%</td>
          <td>host</td>
          <td>Calculate base on cpuacct.stat and cpuacct.usage</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_util_total</td>
          <td>Total time of running percentage of host</td>
          <td>%</td>
          <td>host</td>
          <td>Calculate base on cpuacct.stat and cpuacct.usage</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_util_container_sys</td>
          <td>Time of running kernel processes percentage of container</td>
          <td>%</td>
          <td>container</td>
          <td>Calculate base on cpuacct.stat and cpuacct.usage</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_util_container_usr</td>
          <td>Time of running user processes percentage of container</td>
          <td>%</td>
          <td>container</td>
          <td>Calculate base on cpuacct.stat and cpuacct.usage</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_util_container_total</td>
          <td>Total time of running percentage of container</td>
          <td>%</td>
          <td>container</td>
          <td>Calculate base on cpuacct.stat and cpuacct.usage</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_stat_container_burst_time</td>
          <td>Cumulative wall-time (in nanoseconds) that any CPUs has used above quota in respective periods</td>
          <td>ns</td>
          <td>container</td>
          <td>cpu.stat</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_stat_container_nr_bursts</td>
          <td>Number of periods burst occurs</td>
          <td>count</td>
          <td>container</td>
          <td>cpu.stat</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_stat_container_nr_throttled</td>
          <td>Number of times the group has been throttled/limited</td>
          <td>count</td>
          <td>container</td>
          <td>cpu.stat</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_stat_container_exter_wait_rate</td>
          <td>Wait rate caused by processes outside the container</td>
          <td>%</td>
          <td>container</td>
          <td>Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_stat_container_inner_wait_rate</td>
          <td>Wait rate caused by processes inside the container</td>
          <td>%</td>
          <td>container</td>
          <td>Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_stat_container_throttle_wait_rate</td>
          <td>Wait rate caused by throttle of container</td>
          <td>%</td>
          <td>container</td>
          <td>Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>cpu_stat_container_wait_rate</td>
          <td>Total wait rate: exter_wait_rate + inner_wait_rate + throttle_wait_rate</td>
          <td>%</td>
          <td>container</td>
          <td>Calculate base on throttled_time/hierarchy_wait_sum/inner_wait_sum read from cpu.stat</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>loadavg_container_container_nr_running</td>
          <td>The number of running tasks in the container</td>
          <td>count</td>
          <td>container</td>
          <td>get from kernel via netlink</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>loadavg_container_container_nr_uninterruptible</td>
          <td>The number of uninterruptible tasks in the container</td>
          <td>count</td>
          <td>container</td>
          <td>get from kernel via netlink</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>loadavg_load1</td>
          <td>System load avg over the last 1 minute</td>
          <td>count</td>
          <td>host</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>loadavg_load5</td>
          <td>System load avg over the last 5 minute</td>
          <td>count</td>
          <td>host</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>loadavg_load15</td>
          <td>system load avg over the last 15 minute</td>
          <td>count</td>
          <td>host</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>monsoftirq_latency</td>
          <td>The number of NET_RX/NET_TX irq latency happend in the following regions:<br>0~10 us<br>100us ~ 1ms<br>10us ~ 100us<br>1ms ~ inf</td>
          <td>count</td>
          <td>host</td>
          <td>hook the softirq event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>runqlat_container_nlat_01</td>
          <td>The number of times when schedule latency of processes in the container is within 0~10ms</td>
          <td>count</td>
          <td>container</td>
          <td>hook the scheduling switch event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>runqlat_container_nlat_02</td>
          <td>The number of times when schedule latency of processes in the container is within 10~20ms</td>
          <td>count</td>
          <td>container</td>
          <td>hook the scheduling switch event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>runqlat_container_nlat_03</td>
          <td>The number of times when schedule latency of processes in the container is within 20~50ms</td>
          <td>count</td>
          <td>container</td>
          <td>hook the scheduling switch event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>runqlat_container_nlat_04</td>
          <td>The number of times when schedule latency of processes in the container is more than 50ms</td>
          <td>count</td>
          <td>container</td>
          <td>hook the scheduling switch event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>runqlat_g_nlat_01</td>
          <td>The number of times when schedule latency of processes in the host is within<br>0~10ms</td>
          <td>count</td>
          <td>host</td>
          <td>hook the scheduling switch event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>runqlat_g_nlat_02</td>
          <td>The number of times when schedule latency of processes in the host is within 10~20ms</td>
          <td>count</td>
          <td>host</td>
          <td>hook the scheduling switch event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>runqlat_g_nlat_03</td>
          <td>The number of times when schedule latency of processes in the host is within 20~50ms</td>
          <td>count</td>
          <td>host</td>
          <td>hook the scheduling switch event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>runqlat_g_nlat_04</td>
          <td>The number of times when schedule latency of processes in the host is more than 50ms</td>
          <td>count</td>
          <td>host</td>
          <td>hook the scheduling switch event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>cpu</td>
          <td>reschedipi_oversell_probability</td>
          <td>The possibility of cpu overselling exists on the host where the vm is located</td>
          <td>0-1</td>
          <td>host</td>
          <td>hook the scheduling ipi event and do time statistics via bpf</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>buddyinfo_blocks</td>
          <td>Kernel memory allocator information</td>
          <td>pages</td>
          <td>host</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_events_container_watermark_inc</td>
          <td>Counts of memory allocation watermark increasing</td>
          <td>count</td>
          <td>container</td>
          <td>memory.events</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_events_container_watermark_dec</td>
          <td>Counts of memory allocation watermark decreasing</td>
          <td>count</td>
          <td>container</td>
          <td>memory.events</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_others_container_local_direct_reclaim_time</td>
          <td>Time speed in page allocation in memory cgroup</td>
          <td>nanosecond</td>
          <td>container</td>
          <td>memory.local_direct_reclaim_time</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_others_container_directstall_time</td>
          <td>Memory cgroup&rsquo;s direct reclaim time in try_charge</td>
          <td>nanosecond</td>
          <td>container</td>
          <td>memory.directstall_stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_others_container_asyncreclaim_time</td>
          <td>Memory cgroup&rsquo;s direct reclaim time in cgroup async memory reclaim</td>
          <td>nanosecond</td>
          <td>container</td>
          <td>memory.asynreclaim_stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>priority_reclaim_kswapd</td>
          <td>Kswapd&rsquo;s reclaim stat in priority reclaiming</td>
          <td>pages</td>
          <td>host</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>priority_reclaim_direct</td>
          <td>Direct reclaim stat in priority reclaiming</td>
          <td>pages</td>
          <td>host</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_writeback</td>
          <td>Bytes of file/anon cache that are queued for syncing to disk</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_unevictable</td>
          <td>Bytes of memory that cannot be reclaimed (mlocked etc)</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_shmem</td>
          <td>Bytes of shmem memory</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgsteal_kswapd</td>
          <td>Bytes of reclaimed memory by kswapd and cswapd</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgsteal_globalkswapd</td>
          <td>Bytes of reclaimed memory by kswapd</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgsteal_globaldirect</td>
          <td>Bytes of reclaimed memory by direct reclaim during page allocation</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgsteal_direct</td>
          <td>Bytes of reclaimed memory by direct reclaim during page allocation and try_charge</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgsteal_cswapd</td>
          <td>Bytes of reclaimed memory by cswapd</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgscan_kswapd</td>
          <td>Bytes of scanned memory by kswapd and cswapd</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgscan_globalkswapd</td>
          <td>Bytes of scanned memory by kswapd</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgscan_globaldirect</td>
          <td>Bytes of scanned memory by direct reclaim during page allocation</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgscan_direct</td>
          <td>Bytes of scanned memory by direct reclaim during page allocation and try_charge</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgscan_cswapd</td>
          <td>Bytes of scanned memory by cswapd</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgrefill</td>
          <td>Bytes of memory that is scanned in active list</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_pgdeactivate</td>
          <td>Bytes of memory that is deactivated into inactive list</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_inactive_file</td>
          <td>Bytes of file-backed memory on inactive lru list.</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_inactive_anon</td>
          <td>Bytes of anonymous and swap cache memory on inactive lru list</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_dirty</td>
          <td>Bytes that are waiting to get written back to the disk</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_active_file</td>
          <td>Bytes of file-backed memory on active lru list</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>memory_stat_container_active_anon</td>
          <td>Bytes of anonymous and swap cache memory on active lru list</td>
          <td>bytes</td>
          <td>container</td>
          <td>memory.stat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>mountpoint_perm_ro</td>
          <td>Whether mountpoint is readonly or not</td>
          <td>bool</td>
          <td>host</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_allocstall_normal</td>
          <td>Host direct reclaim count on normal zone</td>
          <td>count</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_allocstall_movable</td>
          <td>Host direct reclaim count on movable zone</td>
          <td>count</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_compact_stall</td>
          <td>Count of memory compaction</td>
          <td>count</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_active_anon</td>
          <td>Number of anonymous pages on active lru</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_active_file</td>
          <td>Number of file-backed pages on active lru</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_boost_pages</td>
          <td>Number of pages in kswapd boosting</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_dirty</td>
          <td>Number of dirty pages</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_free_pages</td>
          <td>Number of free pages</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_inactive_anon</td>
          <td>Number of anonymous pages on inactive lru</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_inactive_file</td>
          <td>Number of file-backed pages on inactive lru</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_kswapd_boost</td>
          <td>Count of kswapd boosting</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_mlock</td>
          <td>Number of locked pages</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_shmem</td>
          <td>Number of shmem pages</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_slab_reclaimable</td>
          <td>Number of relcaimable slab pages</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_slab_unreclaimable</td>
          <td>Number of unrelcaimable slab pages</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_unevictable</td>
          <td>Number of unevictable pages</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_nr_writeback</td>
          <td>Number of writebacking pages</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_numa_pages_migrated</td>
          <td>Number of pages in numa migrating</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_pgdeactivate</td>
          <td>Number of pages which are deactivated into inactive lru</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_pgrefill</td>
          <td>Number of pages which are scanned on active lru</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_pgscan_direct</td>
          <td>Number of pages which are scanned in direct reclaim</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_pgscan_kswapd</td>
          <td>Number of pages which are scanned in kswapd reclaim</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_pgsteal_direct</td>
          <td>Number of pages which are reclaimed in direct reclaim</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>vmstat_pgsteal_kswapd</td>
          <td>Number of pages which are reclaimed in kswapd reclaim</td>
          <td>pages</td>
          <td>host</td>
          <td>/proc/vmstat</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>hungtask_happened</td>
          <td>Count of hungtask events</td>
          <td>count</td>
          <td>host</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>oom_happened</td>
          <td>Count of oom events</td>
          <td>count</td>
          <td>host,container</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>softlockup_happened</td>
          <td>Count of softlockup events</td>
          <td>count</td>
          <td>host</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>mmhostbpf_compactionstat</td>
          <td>Time speed in memory compaction</td>
          <td>nanosecond</td>
          <td>host</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>mmhostbpf_allocstallstat</td>
          <td>Time speed in memory direct reclaim on host</td>
          <td>nanosecond</td>
          <td>host</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>memory</td>
          <td>mmcgroupbpf_container_directstallcount</td>
          <td>Count of cgroup&rsquo;s try_charge direct reclaim</td>
          <td>count</td>
          <td>container</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>IO</td>
          <td>iolatency_disk_d2c</td>
          <td>Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components</td>
          <td>count</td>
          <td>host</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>IO</td>
          <td>iolatency_disk_q2c</td>
          <td>Statistics of io latency for the entire io lifecycle when accessing the disk</td>
          <td>count</td>
          <td>host</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>IO</td>
          <td>iolatency_container_d2c</td>
          <td>Statistics of io latency when accessing the disk, including the time consumed by the driver and hardware components</td>
          <td>count</td>
          <td>container</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>IO</td>
          <td>iolatency_container_q2c</td>
          <td>Statistics of io latency for the entire io lifecycle when accessing the disk</td>
          <td>count</td>
          <td>container</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>IO</td>
          <td>iolatency_disk_flush</td>
          <td>Statistics of delay for flush operations on disk raid device</td>
          <td>count</td>
          <td>host</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>IO</td>
          <td>iolatency_container_flush</td>
          <td>Statistics of delay for flush operations on disk raid devices caused by containers</td>
          <td>count</td>
          <td>container</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>IO</td>
          <td>iolatency_disk_freeze</td>
          <td>Statistics of disk freeze events</td>
          <td>count</td>
          <td>host</td>
          <td>performance and statistics monitoring for BPF Programs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>tcp_mem_limit_pages</td>
          <td>System TCP total memory size limit</td>
          <td>pages</td>
          <td>system</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>tcp_mem_usage_bytes</td>
          <td>The total number of bytes of TCP memory used by the system</td>
          <td>bytes</td>
          <td>system</td>
          <td>tcp_mem_usage_pages * page_size</td>
      </tr>
      <tr>
          <td>network</td>
          <td>tcp_mem_usage_pages</td>
          <td>The total size of TCP memory used by the system</td>
          <td>pages</td>
          <td>system</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>tcp_mem_usage_percent</td>
          <td>The percentage of TCP memory used by the system to the limit size</td>
          <td>%</td>
          <td>system</td>
          <td>tcp_mem_usage_pages / tcp_mem_limit_pages</td>
      </tr>
      <tr>
          <td>network</td>
          <td>arp_entries</td>
          <td>The number of arp cache entries</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>arp_total</td>
          <td>Total number of arp cache entries</td>
          <td>count</td>
          <td>system</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>qdisc_backlog</td>
          <td>The number of bytes queued to be sent</td>
          <td>bytes</td>
          <td>host</td>
          <td>sum of same level(parent major) for a device</td>
      </tr>
      <tr>
          <td>network</td>
          <td>qdisc_bytes_total</td>
          <td>The number of bytes sent</td>
          <td>bytes</td>
          <td>host</td>
          <td>sum of same level(parent major) for a device</td>
      </tr>
      <tr>
          <td>network</td>
          <td>qdisc_current_queue_length</td>
          <td>The number of packets queued for sending</td>
          <td>count</td>
          <td>host</td>
          <td>sum of same level(parent major) for a device</td>
      </tr>
      <tr>
          <td>network</td>
          <td>qdisc_drops_total</td>
          <td>The number of discarded packets</td>
          <td>count</td>
          <td>host</td>
          <td>sum of same level(parent major) for a device</td>
      </tr>
      <tr>
          <td>network</td>
          <td>qdisc_overlimits_total</td>
          <td>The number of queued packets exceeds the limit</td>
          <td>count</td>
          <td>host</td>
          <td>sum of same level(parent major) for a device</td>
      </tr>
      <tr>
          <td>network</td>
          <td>qdisc_packets_total</td>
          <td>The number of packets sent</td>
          <td>count</td>
          <td>host</td>
          <td>sum of same level(parent major) for a device</td>
      </tr>
      <tr>
          <td>network</td>
          <td>qdisc_requeues_total</td>
          <td>The number of packets that were not sent successfully and were requeued</td>
          <td>count</td>
          <td>host</td>
          <td>sum of same level(parent major) for a device</td>
      </tr>
      <tr>
          <td>network</td>
          <td>ethtool_hardware_rx_dropped_errors</td>
          <td>Statistics of inbound packet droped or errors of interface</td>
          <td>count</td>
          <td>host</td>
          <td>related to hardware drivers, such as mlx, ixgbe, bnxt_en, etc.</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_receive_bytes_total</td>
          <td>Number of good received bytes</td>
          <td>bytes</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_receive_compressed_total</td>
          <td>Number of correctly received compressed packets</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_receive_dropped_total</td>
          <td>Number of packets received but not processed</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_receive_errors_total</td>
          <td>Total number of bad packets received on this network device</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_receive_fifo_total</td>
          <td>Receiver FIFO error counter</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_receive_frame_total</td>
          <td>Receiver frame alignment errors</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_receive_multicast_total</td>
          <td>Multicast packets received. For hardware interfaces this statistic is commonly calculated at the device level (unlike rx_packets) and therefore may include packets which did not reach the host</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_receive_packets_total</td>
          <td>Number of good packets received by the interface</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_transmit_bytes_total</td>
          <td>Number of good transmitted bytes, corresponding to tx_packets</td>
          <td>bytes</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_transmit_carrier_total</td>
          <td>Number of frame transmission errors due to loss of carrier during transmission</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_transmit_colls_total</td>
          <td>Number of collisions during packet transmissions</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_transmit_compressed_total</td>
          <td>Number of transmitted compressed packets</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_transmit_dropped_total</td>
          <td>Number of packets dropped on their way to transmission, e.g. due to lack of resources</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_transmit_errors_total</td>
          <td>Total number of transmit problems</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_transmit_fifo_total</td>
          <td>Number of frame transmission errors due to device FIFO underrun / underflow</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netdev_transmit_packets_total</td>
          <td>Number of packets successfully transmitted</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_ArpFilter</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_BusyPollRxPackets</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_DelayedACKLocked</td>
          <td>A delayed ACK timer expires, but the TCP stack can’t send an ACK immediately due to the socket is locked by a userspace program. The TCP stack will send a pure ACK later (after the userspace program unlock the socket). When the TCP stack sends the pure ACK later, the TCP stack will also update TcpExtDelayedACKs and exit the delayed ACK mode</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_DelayedACKLost</td>
          <td>It will be updated when the TCP stack receives a packet which has been ACKed. A Delayed ACK loss might cause this issue, but it would also be triggered by other reasons, such as a packet is duplicated in the network</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_DelayedACKs</td>
          <td>A delayed ACK timer expires. The TCP stack will send a pure ACK packet and exit the delayed ACK mode</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_EmbryonicRsts</td>
          <td>resets received for embryonic SYN_RECV sockets</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_IPReversePathFilter</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_ListenDrops</td>
          <td>When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_ListenOverflows</td>
          <td>When kernel receives a SYN from a client, and if the TCP accept queue is full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is in LISTEN state, and kernel need to drop a packet, kernel would always add 1 to TcpExtListenDrops. So increase TcpExtListenOverflows would let TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would also increase without TcpExtListenOverflows increasing, e.g. a memory allocation fail would also let TcpExtListenDrops increase</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_LockDroppedIcmps</td>
          <td>ICMP packets dropped because socket was locked</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_OfoPruned</td>
          <td>The TCP stack tries to discard packet on the out of order queue</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_OutOfWindowIcmps</td>
          <td>ICMP pkts dropped because they were out-of-window</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_PAWSActive</td>
          <td>Packets are dropped by PAWS in Syn-Sent status</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_PAWSEstab</td>
          <td>Packets are dropped by PAWS in any status other than Syn-Sent</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_PFMemallocDrop</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_PruneCalled</td>
          <td>The TCP stack tries to reclaim memory for a socket. After updates this counter, the TCP stack will try to collapse the out of order queue and the receiving queue. If the memory is still not enough, the TCP stack will try to discard packets from the out of order queue (and update the TcpExtOfoPruned counter)</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_RcvPruned</td>
          <td>After ‘collapse’ and discard packets from the out of order queue, if the actually used memory is still larger than the max allowed memory, this counter will be updated. It means the ‘prune’ fails</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_SyncookiesFailed</td>
          <td>The MSS decoded from the SYN cookie is invalid. When this counter is updated, the received packet won’t be treated as a SYN cookie and the TcpExtSyncookiesRecv counter won’t be updated</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_SyncookiesRecv</td>
          <td>How many reply packets of the SYN cookies the TCP stack receives</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_SyncookiesSent</td>
          <td>It indicates how many SYN cookies are sent</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPACKSkippedChallenge</td>
          <td>The ACK is skipped if the ACK is a challenge ACK</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPACKSkippedFinWait2</td>
          <td>The ACK is skipped in Fin-Wait-2 status, the reason would be either PAWS check fails or the received sequence number is out of window</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPACKSkippedPAWS</td>
          <td>The ACK is skipped due to PAWS (Protect Against Wrapped Sequence numbers) check fails</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPACKSkippedSeq</td>
          <td>The sequence number is out of window and the timestamp passes the PAWS check and the TCP status is not Syn-Recv, Fin-Wait-2, and Time-Wait</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPACKSkippedSynRecv</td>
          <td>The ACK is skipped in Syn-Recv status. The Syn-Recv status means the TCP stack receives a SYN and replies SYN+ACK</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPACKSkippedTimeWait</td>
          <td>The ACK is skipped in Time-Wait status, the reason would be either PAWS check failed or the received sequence number is out of window</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPAbortFailed</td>
          <td>The kernel TCP layer will send RST if the RFC2525 2.17 section is satisfied. If an internal error occurs during this process, TcpExtTCPAbortFailed will be increased</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPAbortOnClose</td>
          <td>Number of sockets closed when the user-mode program has data in the buffer</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPAbortOnData</td>
          <td>It means TCP layer has data in flight, but need to close the connection</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPAbortOnLinger</td>
          <td>When a TCP connection comes into FIN_WAIT_2 state, instead of waiting for the fin packet from the other side, kernel could send a RST and delete the socket immediately</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPAbortOnMemory</td>
          <td>When an application closes a TCP connection, kernel still need to track the connection, let it complete the TCP disconnect process</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPAbortOnTimeout</td>
          <td>This counter will increase when any of the TCP timers expire. In such situation, kernel won’t send RST, just give up the connection</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPAckCompressed</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPAutoCorking</td>
          <td>When sending packets, the TCP layer will try to merge small packets to a bigger one</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPBacklogDrop</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPChallengeACK</td>
          <td>The number of challenge acks sent</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDSACKIgnoredNoUndo</td>
          <td>When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDSACKIgnoredOld</td>
          <td>When a DSACK block is invalid, one of these two counters would be updated. Which counter will be updated depends on the undo_marker flag of the TCP socket</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDSACKOfoRecv</td>
          <td>The TCP stack receives a DSACK, which indicate an out of order duplicate packet is received</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDSACKOfoSent</td>
          <td>The TCP stack receives an out of order duplicate packet, so it sends a DSACK to the sender</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDSACKOldSent</td>
          <td>The TCP stack receives a duplicate packet which has been acked, so it sends a DSACK to the sender</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDSACKRecv</td>
          <td>The TCP stack receives a DSACK, which indicates an acknowledged duplicate packet is received</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDSACKUndo</td>
          <td>Congestion window recovered without slow start using DSACK</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDeferAcceptDrop</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDelivered</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPDeliveredCE</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFastOpenActive</td>
          <td>When the TCP stack receives an ACK packet in the SYN-SENT status, and the ACK packet acknowledges the data in the SYN packet, the TCP stack understand the TFO cookie is accepted by the other side, then it updates this counter</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFastOpenActiveFail</td>
          <td>Fast Open attempts (SYN/data) failed because the remote does not accept it or the attempts timed out</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFastOpenBlackhole</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFastOpenCookieReqd</td>
          <td>This counter indicates how many times a client wants to request a TFO cookie</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFastOpenListenOverflow</td>
          <td>When the pending fast open request number is larger than fastopenq-&gt;max_qlen, the TCP stack will reject the fast open request and update this counter</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFastOpenPassive</td>
          <td>This counter indicates how many times the TCP stack accepts the fast open request</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFastOpenPassiveFail</td>
          <td>This counter indicates how many times the TCP stack rejects the fast open request. It is caused by either the TFO cookie is invalid or the TCP stack finds an error during the socket creating process</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFastRetrans</td>
          <td>The TCP stack wants to retransmit a packet and the congestion control state is not ‘Loss’</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFromZeroWindowAdv</td>
          <td>The TCP receive window is set to no-zero value from zero</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPFullUndo</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPHPAcks</td>
          <td>If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPHPHits</td>
          <td>If a TCP packet has data (which means it is not a pure ACK packet), and this packet is handled in the fast path, TcpExtTCPHPHits will increase 1</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPHystartDelayCwnd</td>
          <td>The sum of CWND detected by packet delay. Dividing this value by TcpExtTCPHystartDelayDetect is the average CWND which detected by the packet delay</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPHystartDelayDetect</td>
          <td>How many times the packet delay threshold is detected</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPHystartTrainCwnd</td>
          <td>The sum of CWND detected by ACK train length. Dividing this value by TcpExtTCPHystartTrainDetect is the average CWND which detected by the ACK train length</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPHystartTrainDetect</td>
          <td>How many times the ACK train length threshold is detected</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPKeepAlive</td>
          <td>This counter indicates many keepalive packets were sent. The keepalive won’t be enabled by default. A userspace program could enable it by setting the SO_KEEPALIVE socket option</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPLossFailures</td>
          <td>Number of connections that enter the TCP_CA_Loss phase and then undergo RTO timeout</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPLossProbeRecovery</td>
          <td>A packet loss is detected and recovered by TLP</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPLossProbes</td>
          <td>A TLP probe packet is sent</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPLossUndo</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPLostRetransmit</td>
          <td>A SACK points out that a retransmission packet is lost again</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPMD5Failure</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPMD5NotFound</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPMD5Unexpected</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPMTUPFail</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPMTUPSuccess</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPMemoryPressures</td>
          <td>Number of times TCP ran low on memory</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPMemoryPressuresChrono</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPMinTTLDrop</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPOFODrop</td>
          <td>The TCP layer receives an out of order packet but doesn’t have enough memory, so drops it. Such packets won’t be counted into TcpExtTCPOFOQueue</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPOFOMerge</td>
          <td>The received out of order packet has an overlay with the previous packet. the overlay part will be dropped. All of TcpExtTCPOFOMerge packets will also be counted into TcpExtTCPOFOQueue</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPOFOQueue</td>
          <td>The TCP layer receives an out of order packet and has enough memory to queue it</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPOrigDataSent</td>
          <td>Number of outgoing packets with original data (excluding retransmission but including data-in-SYN). This counter is different from TcpOutSegs because TcpOutSegs also tracks pure ACKs. TCPOrigDataSent is more useful to track the TCP retransmission rate</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPPartialUndo</td>
          <td>Detected some erroneous retransmits, a partial ACK arrived while were fast retransmitting, so able to partially undo some of our CWND reduction</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPPureAcks</td>
          <td>If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel handles it in the fast path, TcpExtTCPHPAcks will increase 1, if kernel handles it in the slow path, TcpExtTCPPureAcks will increase 1</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPRcvCoalesce</td>
          <td>When packets are received by the TCP layer and are not be read by the application, the TCP layer will try to merge them. This counter indicate how many packets are merged in such situation. If GRO is enabled, lots of packets would be merged by GRO, these packets wouldn’t be counted to TcpExtTCPRcvCoalesce</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPRcvCollapsed</td>
          <td>This counter indicates how many skbs are freed during ‘collapse’</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPRenoFailures</td>
          <td>Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPRenoRecovery</td>
          <td>When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPRenoRecoveryFail</td>
          <td>Number of connections that enter the Recovery phase and then undergo RTO</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPRenoReorder</td>
          <td>The reorder packet is detected by fast recovery. It would only be used if SACK is disabled</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPReqQFullDoCookies</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPReqQFullDrop</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPRetransFail</td>
          <td>The TCP stack tries to deliver a retransmission packet to lower layers but the lower layers return an error</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSACKDiscard</td>
          <td>This counter indicates how many SACK blocks are invalid. If the invalid SACK block is caused by ACK recording, the TCP stack will only ignore it and won’t update this counter</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSACKReneging</td>
          <td>A packet was acknowledged by SACK, but the receiver has dropped this packet, so the sender needs to retransmit this packet</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSACKReorder</td>
          <td>The reorder packet detected by SACK</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSYNChallenge</td>
          <td>The number of challenge acks sent in response to SYN packets</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSackFailures</td>
          <td>Number of failures that enter the TCP_CA_Disorder phase and then undergo RTO</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSackMerged</td>
          <td>A skb is merged</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSackRecovery</td>
          <td>When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1, if sack is not used, TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack begins to retransmit the lost packets</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSackRecoveryFail</td>
          <td>When the congestion control comes into Recovery state, if sack is used, TcpExtTCPSackRecovery increases 1</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSackShiftFallback</td>
          <td>A skb should be shifted or merged, but the TCP stack doesn’t do it for some reasons</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSackShifted</td>
          <td>A skb is shifted</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSlowStartRetrans</td>
          <td>The TCP stack wants to retransmit a packet and the congestion control state is ‘Loss’</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSpuriousRTOs</td>
          <td>The spurious retransmission timeout detected by the F-RTO algorithm</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSpuriousRtxHostQueues</td>
          <td>When the TCP stack wants to retransmit a packet, and finds that packet is not lost in the network, but the packet is not sent yet, the TCP stack would give up the retransmission and update this counter. It might happen if a packet stays too long time in a qdisc or driver queue</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPSynRetrans</td>
          <td>Number of SYN and SYN/ACK retransmits to break down retransmissions into SYN, fast-retransmits, timeout retransmits, etc</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPTSReorder</td>
          <td>The reorder packet is detected when a hole is filled</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPTimeWaitOverflow</td>
          <td>Number of TIME_WAIT sockets unable to be allocated due to limit exceeding</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPTimeouts</td>
          <td>TCP timeout events</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPToZeroWindowAdv</td>
          <td>The TCP receive window is set to zero from a no-zero value</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPWantZeroWindowAdv</td>
          <td>Depending on current memory usage, the TCP stack tries to set receive window to zero. But the receive window might still be a no-zero value</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPWinProbe</td>
          <td>Number of ACK packets to be sent at regular intervals to make sure a reverse ACK packet opening back a window has not been lost</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TCPWqueueTooBig</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TW</td>
          <td>TCP sockets finished time wait in fast timer</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TWKilled</td>
          <td>TCP sockets finished time wait in slow timer</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_TcpExt_TWRecycled</td>
          <td>Time wait sockets recycled by time stamp</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_ActiveOpens</td>
          <td>It means the TCP layer sends a SYN, and come into the SYN-SENT state. Every time TcpActiveOpens increases 1, TcpOutSegs should always increase 1</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_AttemptFails</td>
          <td>The number of times TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_CurrEstab</td>
          <td>The number of TCP connections for which the current state is either ESTABLISHED or CLOSE-WAIT</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_EstabResets</td>
          <td>The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_InCsumErrors</td>
          <td>Incremented when a TCP checksum failure is detected</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_InErrs</td>
          <td>The total number of segments received in error (e.g., bad TCP checksums)</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_InSegs</td>
          <td>The number of packets received by the TCP layer. As mentioned in RFC1213, it includes the packets received in error, such as checksum error, invalid TCP header and so on</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_MaxConn</td>
          <td>The limit on the total number of TCP connections the entity can support. In entities where the maximum number of connections is dynamic, this object should contain the value -1</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_OutRsts</td>
          <td>The number of TCP segments sent containing the RST flag</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_OutSegs</td>
          <td>The total number of segments sent, including those on current connections but excluding those containing only retransmitted octets</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_PassiveOpens</td>
          <td>The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_RetransSegs</td>
          <td>The total number of segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_RtoAlgorithm</td>
          <td>The algorithm used to determine the timeout value used for retransmitting unacknowledged octets</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_RtoMax</td>
          <td>The maximum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>netstat_Tcp_RtoMin</td>
          <td>The minimum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_FRAG_inuse</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_FRAG_memory</td>
          <td>-</td>
          <td>pages</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_RAW_inuse</td>
          <td>Number of RAW socket used</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_TCP_alloc</td>
          <td>The number of TCP sockets that have been allocated</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_TCP_inuse</td>
          <td>Established TCP socket number</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_TCP_mem</td>
          <td>The total size of TCP memory used by the system</td>
          <td>pages</td>
          <td>system</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_TCP_mem_bytes</td>
          <td>The total size of TCP memory used by the system</td>
          <td>bytes</td>
          <td>system</td>
          <td>sockstat_TCP_mem * page_size</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_TCP_orphan</td>
          <td>Number of TCP connections waiting to be closed</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_TCP_tw</td>
          <td>Number of TCP sockets to be terminated</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_UDPLITE_inuse</td>
          <td>-</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_UDP_inuse</td>
          <td>Number of UDP socket used</td>
          <td>count</td>
          <td>host,container</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_UDP_mem</td>
          <td>The total size of udp memory used by the system</td>
          <td>pages</td>
          <td>system</td>
          <td>proc fs</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_UDP_mem_bytes</td>
          <td>The total number of bytes of udp memory used by the system</td>
          <td>bytes</td>
          <td>system</td>
          <td>sockstat_UDP_mem * page_size</td>
      </tr>
      <tr>
          <td>network</td>
          <td>sockstat_sockets_used</td>
          <td>The number of sockets used by the system</td>
          <td>count</td>
          <td>system</td>
          <td>proc fs</td>
      </tr>
  </tbody>
</table>

	<style>
  .feedback--answer {
    display: inline-block;
  }
  .feedback--answer-no {
    margin-left: 1em;
  }
  .feedback--response {
    display: none;
    margin-top: 1em;
  }
  .feedback--response__visible {
    display: block;
  }
</style>
<div class="d-print-none">
<h2 class="feedback--title">Feedback</h2>
<p class="feedback--question">Was this page helpful?</p>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-yes">Yes</button>
<button class="btn btn-primary mb-4 feedback--answer feedback--answer-no">No</button>
<p class="feedback--response feedback--response-yes">
  Glad to hear it! Please <a href="https://github.com/ccfos/huatuo/issues/new">tell us how we can improve</a>.
</p>
<p class="feedback--response feedback--response-no">
  Sorry to hear that. Please <a href="https://github.com/ccfos/huatuo/issues/new">tell us how we can improve</a>.
</p>
</div>
<script>
  const yesButton = document.querySelector('.feedback--answer-yes');
  const noButton = document.querySelector('.feedback--answer-no');
  const yesResponse = document.querySelector('.feedback--response-yes');
  const noResponse = document.querySelector('.feedback--response-no');
  const disableButtons = () => {
    yesButton.disabled = true;
    noButton.disabled = true;
  };
  const sendFeedback = (value) => {
    if (typeof gtag !== 'function') return;
    gtag('event', 'page_helpful', {
      'event_category': 'Helpful',
      'event_label': window.location.pathname,
      'value': value
    });
  };
  yesButton.addEventListener('click', () => {
    yesResponse.classList.add('feedback--response__visible');
    disableButtons();
    sendFeedback( 100 );
  });
  noButton.addEventListener('click', () => {
    noResponse.classList.add('feedback--response__visible');
    disableButtons();
    sendFeedback(0);
  });
</script>
<br />

</div>


          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="官网首页" aria-label="官网首页">
    <a target="_blank" rel="noopener" href="https://huatuo.tech/" aria-label="官网首页">
      <i class="fa fa-home"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="文档中心" aria-label="文档中心">
    <a target="_blank" rel="noopener" href="https://huatuo.tech/docs" aria-label="文档中心">
      <i class="fa fa-file"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/ccfos/huatuo" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        
      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2025&ndash;2026
    <span class="td-footer__authors">HUATUO Authors | <a href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0</a> |</span></span><span class="td-footer__all_rights_reserved">All Rights Reserved</span><span class="ms-2"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener">Privacy Policy</a></span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/docs/js/main.min.5fd3973f3a4fc230f4776f93cc98184325bab1dd8a56a50435b799153a3efc20.js" integrity="sha256-X9OXPzpPwjD0d2&#43;TzJgYQyW6sd2KVqUENbeZFTo&#43;/CA=" crossorigin="anonymous"></script>
<script defer src="/docs/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js" integrity="sha256-c0eKfUgHaYrtfjVesj&#43;YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin="anonymous"></script>
<script src='/docs/js/tabpane-persist.js'></script>

  </body>
</html>